---
layout: blog
istop: true
background-image: /images/2018-03-05-mnesia-learn-01.png
title: mqtt 学习笔记
date: 2018-05-29
category: 编程
tags:
- FLP
- CAP
---

# Basics
任何计算系统所做的最基本的事情无非就是计算和存储这两件事，而分布式编程的核心就在于如何在多个计算机上像在单个计算机上那样去解决问题，但是这种问题并不足以靠单个计算机就能解决，因此我们在需要用到分布式系统。一个大型的分布式系统，只要维护成本能够通过容错软件将其控制下来，每个结点甚至只需要使用普通的家用 PC 就可以组建复杂的分布式计算系统。当分布式计算集群越来越大，高性能结点与低性能结点的性能差距在整个集群的表现下差距会越来越少。

最理想的情况当然是每增加一台新的机器，就能线性增加整个分布式系统的性能，但是这是不可能的，因为数据需要在结点之间互相拷贝，不同结点也要在同一个计算任务上互相协作，还有种种复杂的情况需要考虑，这也是我们要学习分布式算法的原因－来为特定的问题去提供更高效的解决方案。

世间的很多事物大多数都是从很小的规模开始做起的。但是规模一旦到了某个程度，难度就会几何倍数增长，因此像分布式系统这样的东西我们就必须去好好地设计它，保证它有足够的 scalability, 尽可能地去避免规模越大，程序的处理就会越来越失控这样的问题。Scalability 主要包含三个方面，分别是大小上的 Scalability, 地理上的 Scalability以及管理上的 Scalability。

大小上的 Scalability 主要是希望分布式系统在增加节点的时候能尽可能地线性增加性能，数据集的增长也不会增加延迟;
地理上的 Scalability 主要是希望能尽可能地使用多个数据中心去减少响应用户请求的时间，并且能够解决跨数据中心带来的延迟。
管理上的 Scalability 主要是希望即使添加更多的节点，也不会增加整个系统的管理成本。

设计分布式系统的当然是为了提高整个计算系统的性能。 这个性能也主要体现在三个方面：
* 在给定的工作时间段内能够保证在短时间内响应请求，或者说是低延时。
* 高吞吐量（意味着能在单位时间内以非常高的速度处理数据）
* 降低计算资源的消耗。

当然在实际操作中，也存在一定的取舍，当你需要系统具备足够高的吞吐量的时候，响应时间就会延长。低延迟是分布式系统中最有意思的模块，其它性能的增长都能通过买买买去提高性能，而低延迟却不是，它更多的与物理有关，你很难靠砸钱去减少延迟。（因为光速的限制）。

单机计算系统难以具备像分布式系统那样容错性，分布式系统可以在一大堆不可靠的单机节点 ff之上去构建一个可靠的系统。一个分布式系统需要一定的冗余去保证它的容错性。容错性是为了让分布式计算系统具备高可用特性而存在的，可用性是非常重要的，我们通过一个公式来定义何为可用性：可用性＝uptime / (uptime+downtime).

分布式系统会被两个非常重要的物理因素限制住，一下是节点数量，还有一个就是节点之间的距离。
比如说：
* 当独立节点的数量增加了，就有可能让整个系统风险变得更高了，同时也会增加管理成本。
* 独立节点的增加会让整个系统内部节点的通信变得更频繁。
* 地理位置之间距离的增加会让相距较远的节点的通信延迟变得更大。
上述的物理限制都是需要我们在设计分布式系统之前需要考虑的事情。

为了更好地管理整个分布式系统，我们需要引入更多的抽象和模型。抽象是为了通过移除与解决实际问题无关的真实世界的细节来让系统变的更好管理，而模型是以更精准的方式去描述分布式系统的关键属性。

模型大概分为以下三种：
* 系统模型（异步/同步）
* 失败模型（crash-fail, partitions, byzantine）
* 一致性模型（strong,eventual）

抽象和模型能够帮助我们更好地理解这个系统。但是抽象也是有成本的，比如说我们为了让一个分布式系统运作起来更像一个单节点系统，那么我们就需要更多的抽象，就比如说在一个分布式系统上实现一个共享内存的抽象，这是很烧钱的。

一个越是没有足够保障的分布式系统会有更高的性能表现，因为这样的系统有更多活动的自由。具体的原因很难推导，比起一系列节点的集合，人们还是更擅长去推导单个节点的工作。

# Up and Down the level of abstraction

# Time and order

# Replication:preventing divergence

# Replication:accepting divergence

# FLP impossibility

# CAP 定理

# Strong consistency vs other consistency models

## Strong consistency models

### Linearizable consistency

### Sequential consistency

### Client-centric consistency models

### Eventual consistency

## 
