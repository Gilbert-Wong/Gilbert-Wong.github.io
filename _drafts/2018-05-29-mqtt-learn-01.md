---
layout: blog
istop: true
background-image: /images/2018-03-05-mnesia-learn-01.png
title: mqtt 学习笔记
date: 2018-05-29
category: 编程
tags:
- erlang
- mqtt
---

# MQTT　协议概览
   MQTT 是 C/S 架构的，发布/订阅式的消息传输协议，这类机到机的协议主要应用于 IOT（即物联网）领域，该协议主要是跑在 TCP/IP　协议之上，当然也可以跑在其它提供有序，无损，双向连接的网络协议之上。
QTT　协议的特征主要有以下几种：

 使用发布/订阅消息模式，提供了一对多的消息分发和应用程序解耦
 与负载内容无关的消息传输
 消息传递给出三种服务质量
  + 'At most once' 根据操作系统的调度来发送消息，消息可能会丢失，这种等级的服务质量一般用于不是非常重要的地方，比如环境传感器的数据传输，当一条数据读取失败后，就把重新再发布一条数据。
  + 'At least once'　这个等级的服务质量，消息可以确保到达，但是数据可能会重复发送。
  + 'Exactly once' 这个等级的服务质量可以同时确保消息到达并且只到达一次，比如，在帐单系统中，重复或丢失的数据可能会导致帐单系统上的收费不正确。
 传输开销较少，且协议交换最小化，以减少网络流量
  当连接非正常情况下断开了，会有相应的机制去通知相关的人

# MQTT 控制包的结构
 MQTT 协议是通过以特定的方式去交换一系列 MQTT 控制包来完成工作的。MQTT 协议主要分为三块:
 固定头部信息，所有 MQTT 控制包中都含有这一信息
 可调头部 ，一部分 MQTT 控制包中会有
 payload，一部分 MQTT 控制包中会有

## 固定的头部信息
定头部信息的第一个字节前 4 位是 MQTT 控制包的类型，后 4 位是 MQTT 控制包类型对应的 flag, 第二个字节及之后则表示的是剩余长度。

### MQTT 控制类型
制包有 16 个值，7-4 位 4 个 bit 来表示这 16 个值
 0  :  Reserved, 预留位, 禁止使用　
 1  :  CONNNECT, 客户端到服务端, 客户端发送请求到服务端
 2  :  CONNACK, 服务端到客户端, 服务端连接确认
 3  :  PUBLISH, 客户端到服务端或服务端到客户端, 发布消息
 4  :  PUBACK, 客户端到服务端或服务端到客户端, 发布确认信息
 5  :  PUBREC, 客户端到服务端或服务端到客户端, 接收到发布（保证交付第一部分）
 6  :  PUBREL, 客户端到服务端或服务端到客户端, 发布中（保证交付第二部分）
 7  :  PUBCOMP, 客户端到服务端或服务端到客户端, 发布完成（保证交付第三部分）
 8  :  SUBSCRIBE, 客户端到服务端, 客户端订阅请求
 9  :  SUBACK, 服务端到客户端, 订阅确认
 10 :  UNSUBSCRIBE, 客户端到服务端, 取消订阅请求
 11 :  UNSUBACK, 服务端到客户端, 取消订阅确认
 12 :  PINGREQ, 客户端到服务端, ping 请求
 13 :  PINGRESP, 服务端到客户端, ping 响应
 14 :  DISCONNECT, 客户端到服务端, 客户端正在断开连接
 15 :  Reserved, 预留位, 禁止使用

### Flags
lags 有 3－1 位四个 bit 来分别对应 MQTT 控制包的 16 个值。
QTT 3.1.1 协议除了指定 PUBLISH 控制包的类型以外, 其他控制包的类型都是预留位。
说明 PUBLISH 控制包类型时, Bit 3 表示 DUP, Bit2 和 Bit1 表示QoS, Bit0　表示 RETAIN
注：DUP 表示传两份 PUBLISH 控制包
   QoS 表示 PUBLISH 服务质量
   RETAIN　表示 PUBLISH  保留 flag

### 剩余长度
余长度表示当前剩余字节数, 包含了可调头部和payload的数据字节数, 但是它并不包含用于编码剩余长度的字节。

余长度是通过一个可变长度的编码方案去编码的, 该方案使用了单个字节用来表示长度, 最高能表示到 127, 如果长度更大的话, 那就再增加一个字节来表示, 最高能加到四个字节。虽然单个字节的长度有 8 位, 但是只有其中 7 位来表示长度, 另外一位是最重要的一位, 用来表示是否需要增加字节来表示长度。

高 4个字节可以表示到 268435455。

## 可调头部

些 MQTT 控制包类型包含了可调头部组件, 它处于固定头部与payload之间。可调头部的内容会随着数据包　类型的不同而不同, 不同类型数据包的可调头部的标识域则都是相同的。

### 标识
多控制包类型的可调头部组件都包含 2 字节的 标识域，这些控制包包括: PUBLISH (当 QoS > 0 时)，　PUBACK, PUBREC,　PUBREL, PUBCOMP, SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK。

UBSCRIBE, UNSUBSCRIBE  以及 PUBLISH（当 QoS > 0 时）, 控制 必须包含一个非 0 的 16 位 标识。每次客户端发送一个这些类型的新的数据包, 它就应该分配一个当前未使用的数据包标识。

果客户端重新发送了一个特定的控制数据包 ，那么它就必须随后发送一个相同数据包标识的数据 。当客户端已经发送过确认数据包后， 标识可以重新使用。对于 QoS 1 等级的 PUBLISH 数据包 ，会发送 PUBACK 来确认;　对于QoS 2 等级，则是使用 PUBCOMP 来确认。对于 SUBSCRIBE 或 UNSUBSCRIBE 数据包 ，会发送相应的 SUBACK 和 UNSUBACK 来确认。

 PUBLISH 的 QoS 大于 0 时，服务端是和客户端一样的机制。

 PUBLISH  的 QoS 值等于 0 时，PUBLISH **绝对不能** 包含数据包标识。

UBACK, PUBREC 或　PUBREL  包含的数据包标识必须和最初发送的 PUBLISH 数据包包的标识一样。SUBACK和 UNSUBACK 数据包与上述 相似，都需要与相对应的 SUBSCRIBE 和 UNSUBSCRIBE  拥有同样的标识符。

户端和服务端都是各自分配数据包标识。因此，客户端服务端可以使用同一个数据包标识来同时进行消息交换。

## payload

payload 位于部分 MQTT 控制数据包的末尾。在 PUBLISH 数据包的例子中，它是应用消息。
在 16 种控制数据包类型中，必须包含payload信息的数据包有 CONNECT, SUBSCRIBE, SUBACK, UNSUBSCRIBE。PUBLISH　数据包中，payload信息是可选的。

# MQTT 控制数据包

## CONNECT - 客户端向服务端发送一个连接请求。
客户端向服务端建立网络连接后，从客户端发往服务端的第一个数据包必须是 CONNECT 包。

整个网络连接过程中，客户端只能发送一个 CONNECT 数据包。当客户端发送第二个 CONNECT 包的时候，服务端将其视为违反协议，并断开和客户端的连接。

payload 包含一个或多个域。它们规定客户端有一个唯一的客户端标识，一个 Will topic,  一个 Will Message, 用户名和密码。除了客户端标识外其他都是可选的，它们的形式是由可调头部的 flags 来决定的。

### 固定头部
固定头部一个字节上面已经详细介绍过。

### 可调头部
调头部的长度为 10 字节，CONNECT 数据包的可调头部是有四个域有序构成的，分别是 Protocal Name(协议名称)，Protocal Level(协议等级)，Connect Flags 以及 Keep Alive.

#### 协议名称
调头部前 2 个字节是分别是 MSB 的长度和 LSB 的长度，接着后面的四个字节分别是'M' ,'Q', 'T', 'T'。

果协议名不正确，服务器会主动断开和客户端的连接，或者它可能会按照其他规范来处理 CONNECT 数据包，在后面一种情况下，服务器绝不能继续按照本规范来处理 CONNECT 数据包。

似于防火墙这样的包检测工具可以鉴别 MQTT 流量。

#### 协议等级
调头部第 7 个字节是用来表示协议等级，8 位无符号值表示的是客户端使用协议的版本. MQTT 3.1.1使用的版本号是 4(0x04)。如果服务端不支持协议等级，那么服务端必须响应一个带有 CONNACK 的 CONNECT 数据包来返回 0x01 码（不可接受的协议版本），然后断开与客户端的连接。

#### Connect Flags
调头部第 8 个字节是 Connect Flag 字节，包含大量参数用来指定 MQTT 连接的行为。它还可以用来表示payload中的字段是否存在。

connect Flag 位的按照大端序是 7,6,5,4,3,2,1,0,分别对应的是 用户名 Flag, 密码 Flag, Will Retain, Will QoS, Will Flag, Clean Session, Reserved。服务器必须验证 CONNECT 控制包中的预留 flag 是否设置为 0, 如果不为 0, 就断开与客户端的连接。


#### Clean Session 
Clean Session 是 Connect Flags 字节中位 1 对应的 flag。

一位是用来表示 Session 状态的处理。客户端和服务端可以存储会话状态, 来使消息能够在网络连接中持续而可靠地传递。这一位是用来控制会话状态的生命周期的。

如果 Clean Session 被设定为 0, 服务端必须基于当前会话状态来恢复与客户端的连接, 如果客户端与服务商之间没有建立会话，那么服务端必须新建立一个会话。在客户端和服务端断开连接后，这两者都要存储会话，将 Clean Session 设置为 0 的连接断开后，服务器还需要进一步存储客户端在断开连接时订阅的 QoS1 和 QoS2 的消息，作为会话状态的一部分。它也可以存储符合相同标准的 QoS 等级 0 的消息。

如果 Clean　Session 被设为 1 时，客户端服务器都必须丢弃之前的会话，然后创建一个全新的会话。该会话的生命周期即网络连接的连接时长（也就意味着网络连接一断，该会话就要结束）。与该会话相关的所有状态数据都不会被之后的会话所使用。

客户端中的会话状态包含了：
1. 已经发送给服务器却还未完全确认的 QoS1 和 QoS2 的消息。
2. 已经收到的服务器发送来却还未完全确认的 QoS2 数据。

服务器中的会话状态包含了：
1. 现存的会话，即使会话状态的剩余部分是空的
2. 客户端的订阅内容。
3. 已经发送给客户端却还未完全确认的 QoS1 和 Qos2 的消息。
4. 准备传输给客户端的 QoS1 和 QoS2 消息。
5. 已经收到的发送来却还未完全确认的 QoS2 数据。
6. (可选项)，准备传输给客户端的 QoS0 消息。

Retained　消息不构成服务器会话状态的一部分，在会话结束前，它们绝不能被删除。

注：如果你在断开连接的时候不想丢失任何消息，请把 Clean Session 设置为 0，并使用 QoS0 和 QoS1 的消息。当客户端 Clean Session 设置为 0 的时候, 服务器还会在断开连接的时候保存客户端的会话信息，如果客户端在之后还打算重新连接服务器，那么最好把 Clean Session 设置为 0，如果客户端在未来不会在和服务器建立连接，那么将 Clean Session 设置为 1 比较好。

#### Will Flag
当 Will Flag 设置为 1，则说明如果连接请求被接受，Will Message必须存储在服务器上并和网络连接关联起来。当网络连接关闭时，必须要发布 Will Message，除非服务器收到 DISCONNECT 数据包后已经删除了 Will Message。
 通常 Will Message 会被发布的情况有以下几种：
 1. 服务器探测到 I/O 出错或网络出现问题。
 2. 在 Keep alive 时间段中，客户端没有成功通信。
 3. 客户端在没有先发送 DISCONNECT 数据包就断开了网络连接。
 4. 服务器因为协议错误关闭了网络连接。

如果 Will Flag 设置为 1，在 Connect Flags 中的 Will QoS 和 Will Retain 域必须被服务器使用，并且 Will Topic 和 Will Message 必须在payload中。
 Will Message  被发布或者当服务器从客户端那里收到 DISCONNECT 数据包时，Will Message必须从服务器中存储的会话状态中删除。

果 Will Flag 被设置为 0 , 那么在 Connect Flags 中的 Will QoS 和 Will Retain 域必须设置为 0，而且 Will Topic 和 Will Message 域不能在payload中。
果 Will Flag 设置为 0，当网络连接断开的时候，Will Message 绝不能被发布出来。

务器应该及时地发布 Will Message。万一服务器关机了或者崩溃了，会把 Will Message 推迟到下一次服务器重启后发布，这种情况会导致服务器崩溃与 Will Message 被发送之前存在延迟。

#### Will QoS
于 Connect Flags 字节的第 3、4 位。
发布 Will Message 的时候，这两位用来指明 QoS 的等级。

果 Will Flag 被设为 1，那么 Will QoS 必须被设为 0(0x00)。如果 Will Flag 被设为 1，那么 Will QoS 的值可以被设为 0(0x00), 1(0x01), 2(0x02)，但是绝对不能设置为 3(0x03)。

#### Will Retain
于 Connect Flags 的第 5 位。
这一位用来表明当 Will Message 被发布的时候，是否需要保留 Will Message。
当 Will Flag 被设定为 0 的时候，Will Retain Flag 必须设定为 0.
当 Will Flag 被设定为 1 的时候，
 * 如果 Will Retain 设定为 0，服务器必须将 Will Message 作为 non-retained 消息来发布。
 * 如果 Will Retain 设定为 1，服务器发布将 Will Message 作为 retained 消息来发送。
 
#### User Name Flag
于 Connect Flags 字节的第 7 位。
果 User Name Flag 设为 0，user name 就不应该在payload中。
果 User Name Flag 设为 1，user name 就放在payload中。

#### Keep Alive
eep Alive 占据了可变头部的第 9，10 个字节。

eepAlive 是一个以秒为单位的时间间隔，以 16 个 bit 来表示， 它表示一个最大的一个时间间隔，客户端传送完一个控制数据包到开始传送下一个控制数据包的时间间隔不能超过这个时间间隔，这是由客户端来负责确保的部分，如果客户端不发送控制数据包，它必须发送一个 PINGREQ 数据包。

户端可以在在任意时刻发送 PINGREQ 包，不用关心 Keep Alive 的值，然后再用 PINGREQ 来确定网络和服务器是否正常工作。

果客户端在发送 PINGREQ 后的很长一段时间内都没有收到 PINGRESP 包，它就应该关闭到服务器的网络连接。

eepAlive 值为 0 就会关闭 keep alive 机制，这就意味着，服务器不需要以不活动为由断开与客户端的连接。请注意，服务器可以随时断开它认为处于非活动状态或无响应状态的客户端，而不考虑该客户端提供的Keep Alive值。

eepAlive 的值通常只有几分钟，最大可以到 18 小时 12 分钟 15 秒。

### payload
ONNECT 数据包的payload包含一个或多个长度前缀域，其存在由可变头部的 Flags 来确定。这些域（如果存在），必须以 Client Identifier, Will Topic, Will Message, User Name, Password 的顺序出现。

#### Client Identifier
lient Identifier 是用来给服务器辨别客户端的。每一个连接服务器的客户端都有一个特定的 ClientId。ClientId 必须用来给客户端和服务器来识别它们互相建立的 MQTT  会话的状态。

lient Identifier(ClientId) 必须存放在 CONNECT 数据包payload的第一个域踢。

lientId 必须被定义为一个 UTF-8 编码的字符串。

务端必须支持长度在 1 到 23 个 UTF-8 编码字节之间的 ClientIds，并且只能包含 0-9.a-z,A-Z 这些字符。 服务器也可以支持超过 23 个字节的 ClientId ，也可以支持包含 0-9,a-z,A-Z 以外字符的 ClientId。

务器甚至还可以支持 0 字节长的 ClientId，但是如果这么做，服务器会把它作为特例对待，并给它分配一个唯一的 ClientId，然后它必须像服务器提供了 ClientId 那样处理 CONNECT 数据包。

果客户端用的是 0 字节的 ClientId，那么客户端必须把 CleanSession 设置为 1。
果客户端在用 0 字节 ClientId 的同时还把 CleanSession 设置为 0，那么服务器必须响应一个带有返回 code 0x02(拒绝识别)的 CONNACK 的 CONNECT 包，然后关闭网络连接。

：客户端实现必须提供一个方便的机制去生成随机 ClientId。如果 CleanSession 设置为 0 的时候，就不推荐使用这种方法了。

#### Will Topic
果 Will Flag 被设为 1，那么 Will Topic 是payload的下一个域，与 Client Identifier 一样，Will Topic 必须是一个 UTF-8 的字符串。

#### Will Message
果 Will Message 被设为 1，那么 Will Topic 是payload的下一个域。Will Message 定义了发布到 Will Topic 的应用程序消息。这个域包含了由两个字节的长度组成，随后是 Will Message 的payload，用一个或多个字节序列来表示。该长度给出了随后数据的字节数，不包含长度本身的占据的两个字节。
 Will Message 发布到 Will Topic 的时候，它的payload仅仅只包含该域的数据部分，不包括前面两个长度字节。

#### User Name
 User Name Flag 被设置为 1 的时候，那么 User Name 是payload的下一个域，User Name必须是一个 UTF-8 的字符串，它是用来给服务器做认证和授权的。

#### Password
果 Password Flag 被设为 1，那么 Password 是payload的下一个域，Password 域包含了一个带有两字节长度域作为前缀的 0 到 65535 字节的二进制数据块。和 User Name 一样，这个两字节的长度域是用来表示二进制数据块的字节数。

### Response
一个服务器可能在一个 TCP 端口或其它网络端口上同时支持多个协议（该协议的更早版本），如果服务器确定使用 MQTT3.1 版本的协议，那么它将会验证以下连接：
1. 如果服务器在网络连接建立后的一段时间内都没有收到 CONNNECT 数据包，那么服务器就会关闭连接。
2. 服务器必须验证 CONNECT 数据包是否符合要求，如果不符要求，不用发送 CONNACK 包就可以关闭网络连接。
3. 服务器可以检查 CONNECT 数据包的内容是否满足进一步的要求，也可以执行认证和授权检查。如果这些检查都失败了，它就应该发送一个适当的带有非零返回码的 CONNACK响应，并且它必须关闭网络连接。

 如果验证成功了，服务器就会执行接下来几个步骤。
1. 如果 ClientId 表示客户端已经连接到服务器，那么服务器必须断开与已存客户端的连接。
2. 服务器必须执行 CleanSession 的处理。
3. 服务器必须确认带有包含一个 0 返回码的 CONNACK 包的 CONNECT 包。
4. 开始消息传输并且保持活动状态。

客户端在发送 CONNECT 数据包后可以立即进一步发送控制数据包，客户端不需要等待从服务器端传来的 CONNACK 数据包。如果服务器拒绝了连接，它就不会在 CONNECT 包传过来之后处理任何数据。

 注：客户端一般会等待 CONNACK 数据包，但是如果客户端在它收到 CONNACK 之前就享有足够的自由来发送控制数据包，那么就可以简化客户端的实现， 因为它不用监控连接状态。如果服务器拒绝了连接，客户端在收到 CONNACK 数据包的前发送的任意数据都不会被处理。
 
## CONNACK -确认连接请求
CONNACK 数据包是服务器发送的用来响应客户端发来的 CONNECT 包。服务器发送到客户端的第一个包必须是 CONNACK 包。

如果客户端在一段时间内没有从服务器那里收到 CONNACK 的数据包，客户端就应该关闭网络连接。这个时间长度取决于应用程序和通信基础设施的类型。

### 固定头部
固定头部一个字节上面已经详细介绍过。

### CONNACK 数据包可调头部
第一个字节表示 Connect Acknowledged Flags。
第二个字节表示 Connect Return code。

#### Connect Acknowledged Flags
第一个字节的 1-7 位是预留位，全部置为 0。0 位是 Session Present Flag 。

#### Session Present
如果服务器接受了一个 CleanSession 设为 1 的连接，那么服务器就必须把 Session Present 设为 0。在 CONNACK 包中设置 0 返回码是例外。

如果服务器接受了一个 CleanSession 设为 0 的连接，在 Session Present 中设置的值取决于服务器是否已为所提供的客户端 ID 存储会话状态。如果服务器已经存储了会话状态，那么它必须在 CONNACK 包中将 Session Present 设置为 1，如果服务器没有存储任何会话状态，那么它必须在 CONNACK 包中将 Session Present 设置为 0。除非在 CONNACK 包中。在 CONNACK 包中设置 0 返回码是例外。

Session Present Flag 使客户端能够确定服务器和客户端是否具有关于是否已存储会话状态的一致视图。

一旦会话的初始设置完成，存储会话状态的客户端将会期望服务器去维持它存储的会话状态。如果客户端从服务器收到的 Session Present 的值不符合预期，客户端可以选择继续处理会话或者断开连接。客户端可以通过断开连接并将Clean Session设置为1，然后再次断开，丢弃客户端和服务器上的会话状态。

如果服务器发送了包含非 0 返回码的 CONNACK 包，它必须将 Session Present 设置为 0。

#### Connect Return code
位于可调头部的第二个字节。

如果服务器收到了一个结构良好的 CONNECT 数据包却因为某些原因无法处理，那么服务器就应该尝试发送一个包含适当非零连接返回码的 CONNACK 包。

如果服务器发送了一个包含非零返回码的 CONNACK 数据包，那么它就必须关闭网络连接。

Connect Return code 可以用 256 个值来表示。

0(0x00): 接受连接请求。 
1(0x01): 连接拒绝，无法接受的协议版本;服务器可能不支持客户端请求的 MQTT 协议等级。
2(0x02): 连接拒绝，拒绝识别; Client identifer。
3(0x03): 连接拒绝，服务器不可用;网络连接已建立，但是 MQTT 服务无法获取。
4(0x04): 连接拒绝，用户名或密码不正确;　用户名或密码的数据是畸形的。
5(0x05): 连接拒绝，客户端没有被授权去连接。
6-255  : 预留给未来使用。

如果不属于上述情况中任意一种的返回码被认为是可以用的，那么服务器必须不发送 CONNACK  就关闭网络连接。

### payload
CONNACK 数据包没有payload。

## PUBLISH - 发布消息
PUBLISH 控制数据包可以在客户端与服务器之间互相转发，用来传输应用程序消息。

### 固定头部
固定头部一个字节上面已经详细介绍过。

### 可调头部
可调头部包含以下几个域，按照次序排列分别是 Topic Name,Packet Identifier。

#### Topic Name
Topic Name 标记payload信息发布的信息通道。
Topic Name 只能 PUBLISH 数据包可变头部的第一个域来表示。它也必须用 UTF-8 编码的字符串来表示。
在 PUBLISH 包的 Topic Name 绝对不能包含通配符。
由服务器发送给订阅客户端的 PUBLISH 数据包的主题名称必须根据后面定义的匹配进程去匹配订阅 Topic Filter。但是，由于允许服务器覆盖 Topic Name。因此它可能与原始 PUBLISH 包中的 Topic Name 不同

#### Packet Identifier
只有当 QoS 等级为 1 或 2 的时候，Packet identifer 域才会在 PUBLISH 包中出现。

### payload
payload包含了被发布的应用程序数据，数据的内容和格式由应用程序指定。payload的长度可以通过将固定头部中的 Remaining Length 减去可调头部的长度来计算出来。 它对包含零长度payload的 PUBLISH 数据包有效。

### Response
PUBLISH 数据包的接受者必须按照下面的规则来响应，预期的 PUBLISH 包的响应取决于 PUBLISH 包的 QoS 等级。

QoS0: None
QoS1: PUBACK 包
QoS2: PUBREC 包

### Actions

