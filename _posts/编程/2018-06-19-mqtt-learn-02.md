---
layout: blog
istop: true
background-image: /images/2018-05-29-mqtt-learn-01.png
title: mqtt 学习笔记(1)
date: 2018-05-29
category: 编程
tags:
- erlang
- mqtt
- v5.0
---

# MQTT v3.1.1 diff MQTT v5.1

## 开头简介的变化
MQTT　5.0 协议相比 MQTT 3.1.1　变了很多，这里写一个笔记罗列一下，MQTT 5.0 Spec 中和 MQTT 3.1.1 Spec 中有哪些异同点。
 
Application Message 定义的变化:
相比 MQTT v3.1.1，MQTT v5.1 的 Application Message 除了不仅包含相关联的 QoS 等级和 Topic Name。还包含了 Payload 数据和一个属性的集合。

Client 定义的变化
Client 可以打开向服务器的连接，关闭对服务器的连接。

Server 定义的变化
多了一条：Server 可以关闭到服务器的网络连接

新增关于 Shared Subscription（共享订阅） 的定义：
一个共享订阅由由一个 Topic Filter 和一个 QoS 最大值构成，Shared Subscription 可以关联多个 Session 用于更广泛的消息交换范式。匹配 Shared Subscription 的应用消息只会发送给与这些会话之一关联的客户端。一个会话可以订阅多个 Shared Subscription,也可以同时订阅 Shared Subscription 和非 shared Subscription。

新增关于 Wildcard Subscription 的定义描述：
这个其实在 v3.1.1 中提到了，只不过 v3.1.1 没有单独拿出来放在术语列表中。

新增 Malformed Packet 的定义描述：
无法被 parsed 的 Control Packet

新增 Protocol Error 的定义描述：
Control Packet 虽然被 parse 成功，但是它包含的数据违反了协议标准或者它与服务器和客户端的状态不一致, 这种情况需要作为 error 来处理。

新增 Will Message 的定义描述：
若网络连接非正常断开， 服务器需要发布的应用消息。

 MQTT v5.0 最主要的添加的几个最重要的新特性：
 * 增强了扩展性
 * 改善了错误报告的方式
 * 形式化了一些通用范式，比如说 capability 和 request response
 * 多了扩展机制，比如说用户属性(user properties)
 * 性能改善，并且添加了对 small clients 的支持

## MQTT 控制包格式上的变化
MQTT v5.0 中的控制包的结构大体上和之前 v3.1.1 是一模一样的，都是分为 Fixed header，Variable Header, Payload 三块。Fixed header 在所有 MQTT 控制包中都，后两者未必。
 
在 MQTT 控制包类型上有几点重要的变化:
1. DISCONNECT 包中数据流向并不仅仅是客户端到服务器，还包括服务器到客户端，功能上的也不再是表示 Client 正在断开连接，而是用来表示通知连接断开。
2. 最后一个 0x15 原本是预留位，在 MQTT v5.0 中这一位被用了起来，它这里从 Reserved 变为了 Auth，数据流向为双向的 client <-> server。用来表示认证的交换。

用来表示 Flag 的那四位，原本接收者收到无效的 Flags，会强制断开连接，在 v5.0 中会被视 Malformed Packet，等待进一步的错误处理。

关于 Packet Identifier　这里要注意一下：新添加的 AUTH 控制包类型是不包含 Packet Identifier 字段的。

MQTT v5.0 增加的一个最重要之一的一个东西就是 Properties。像CONNECT,CONNACK,PUBLISH,PUBACK,PUBREC.etc 这些包中 Variable Header 的最后一个字段都是一组 properties。在 CONNECT 包中，Payload 的 Will Properties 字段中也有一系列可选的 Properties 集。

property length 是用来描述 properties 长度的，这个长度不包含 properties length 它本身，如果没有 properties，那么就把 property length 设为 0。

下面列一下关于 properties 的用法，类型以及所在的控制包。
1 (0x01) Payload 格式指示器， 字节，位于 PUBLISH 控制包, Will properties中。
2 (0x02) Message 到期间隔，四字节整形，位于 PUBLISH 控制包, Will properties中。
3 (0x03) 内容类型，UTF-8 编码字符串，位于 PUBLISH 控制包, Will properties中。
8 (0x08) 响应 Topic，UTF-8 编码字符串，位于 PUBLISH 控制包, Will properties中。
9 (0x09) 关联数据，二进制数据，位于 PUBLISH 控制包, Will properties中。
11(0x0B) Subscription Identifier，它是  Variable Byte 整形，位于 PUBLISH 控制包, SUBSCRIBE 中。
17(0x11) Session 到期间隔，四字节整形，可以位于 CONNECT,CONNACK, DISCONNECT中。
18(0x12) 已分配的 Client Identifier，UTF-8 字符串，位于 CONNACK 中。
19(0x13) Server keep alive，两字节整形，位于 CONNACK 中。
21(0x15) Authentication Method（验证方法）， UTF-8 编码字符串，位于 CONNECT, CONNACK, AUTH 包中。
22(0x16) Authentication Data (验证数据)，二进制数据，，位于 CONNECT，CONNACK，AUTH 中。
23(0x17) Request Problem Information, 字节，位于 CONNECT 中。
24(0x18) Will Delay interval，四字节整形，位于 Will Properties。
25(0x19) Request Response Information, 字节，位于 CONNECT 中。
26(0x1A) Response Information， UTF-8 编码字符串，位于 CONNACK 中。
28(0x1C) Server Reference，UTF-8 编码字符串， 位于 CONNACK，DISCONNECT 中
31(0x1F) Reason String，UTF-8 编码字符串，位于 CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBACK, UNSUBACK, DISCONNECT, AUTH 包中。
33(0x21) Receive Maximum，两字节整形，位于 CONNECT,CONNACK 中。
34(0x22) Topic Alias Maximum，两字节整形，位于 CONNECT, CONNACK 中。
35(0x23) Topic Alias，两字节整形，位于 PUBLISH 包中。
36(0x24) Maximum QoS，字节，位于 CONNACK 包中。
37(0x25) Retain Available，字节，位于 CONNACK 包中。
38(0x26) User Property，UTF-8 字符串对，位于 CONNECT, CONNACK, PUBLISH, Will Properties, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK, DISCONNECT, AUTH。
39(0x27) Maximum Packet Size，四字节整形，位于 CONNECT,CONNACK 包中。
40(0x28) Wildcard Subscription, 字节，位于 CONNACK 包中。
41(0x29) Subscription Identifier Available，字节，位于　CONNACK 包中。
42(0x2A) Shared Subscription Available，字节，位于 CONNACK 包中。

虽然 Property Identifier 被定义为 Variable Byte Integer，但是在这个版本的 mqtt 中，Property Identifier 长度都不会超过一个字节。

关于 Payload，和 v3.1.1 不同，在 v3.1.1 中，UNSUBACK 包中不包含 Payload，而在 5.0 的版本中，UNSUBACK 包包含 Payload，新引入的 AUTH 包不包含 Payload。

MQTT v5.0 中新引入了一个东西叫 Reason Code。它是用来表明操作结果的一个单字节无符号值，小于 0x80的 Reason Codes 表明操作的结果是成功的，正常的成功操作返回的 Reason Code 值为 0。 如果返回的 Reason Code 大于等于 0x80，就说明操作失败了。

CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, DISCONNECT 和 AUTH 控制包有单个 Reason Code 作为一部分在Variable Header 中。而 SUBACK 和 UNSUBACK 包在 Payload 中包含了一张一个或多个 Reason Codes 的列表。

以下的 Reason Codes 一览列表:
0    0x00             Success                      ; CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, UNSUBACK, AUTH
0    0x00       Normal disconnection               ; DISCONNECT
0    0x00          Granted QoS 0                   ; SUBACK
1    0x01          Granted QoS 1                   ; SUBACK
2    0x02          Granted QoS 2                   ; SUBACK
4    0x04    Disconnect with Will Message          ; DISCONNECT 
16   0x10     No matching subscribers              ; PUBACK,PUBREC
17   0x11      No subscription existed             ; UNSUBACK
24   0x18      Continue authentication             ; AUTH
25   0x19          Re-authenticate                 ; AUTH
128  0x80          Unspecified error               ; CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT
129  0x81          Malformed Packet                ; CONNACK, DISCONNECT
130  0x82           Protocol Error                 ; CONNACK, DISCONNECT
131  0x83  Implementation specific error           ; CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT
132  0x84  Unsupported Protocol Version            ; CONNACK
133  0x85   Client Identifier not valid            ; CONNACK
134  0x86     Bad User Name or Password            ; CONNACK
135  0x87           Not authorized                 ; CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT
136  0x88       Server unavailable                 ; CONNACK
137  0x89            Server busy                   ; CONNACK, DISCONNECT
138  0x8A              Banned                      ; CONNACK
139  0x8B       Server shutting down               ; DISCONNECT
140  0x8C       Bad authentication method          ; CONNACK, DISCONNECT
141  0x8D         Keep Alive timeout               ; DISCONNECT
142  0x8E         Session taken over               ; DISCONNECT
143  0x8F         Topic Filter invalid             ; SUBACK,UNSUBACK,DISCONNECT
144  0x90         Topic Name invalid               ; CONNACK, PUBACK, PUBREC, DISCONNECT
145  0x91       Packet Identifier in use           ; PUBACK, PUBREC, SUBACK, UNSUBACK
146  0x92    Packet Identifier not found           ; PUBREL,PUBCOMP
147  0x93    Receive Maximum exceeded              ; DISCONNECT
148  0x94    Topic Alias invalid                   ; DISCONNECT
149  0x95      Packet too large                    ; CONNACK, DISCONNECT
150  0x96      Message rate too high               ; DISCONNECT
151  0x97          Quota exceeded                  ; CONNACK, PUBACK, PUBREC, SUBACK, DISCONNECT
152  0x98       Administrative action              ; DISCONNECT
153  0x99      Payload format invalid              ; CONNACK,PUBACK, PUBREC, DISCONNECT
154  0x9A      Retain not supported                ; CONNACK,DISCONNECT
155  0x9B       QoS not supported                  ; CONNACK,DISCONNECT
156  0x9C      Use another server                  ; CONNACK,DISCONNECT
157  0x9D     Server moved                         ; CONNACK,DISCONNECT
158  0x9E      Shared Subscriptions not supported  ; SUBACK, DISCONNECT
159  0x9F     Connection rate exceeded             ; CONNACK,DISCONNECT
160  0xA0     Maximum connect time                 ; DISCONNECT
161  0xA1  Subscription Identifiers not supported  ; SUBACK, DISCONNECT
162  0xA2   Wildcard Subscriptions not supported   ; SUBACK, DISCONNECT

对于 0x91 的 Reason Code ，对于它的响应应该是尝试修复状态，或者通过使用 Clean Start 设为 1 来重置 Session 状态，或者判断 Client 和 Server 的实现是否是有缺陷的。

# MQTT 控制包的变化
## CONNECT 包
在 v5.0 中，CONNECT 包有几个地方改了。

### CleanStart
第一个是 Protocol Level 那里改成了版本 0x05。第二个是原来的 CleanSession 改为了 CleanStart。
CleanSession 是用来控制 Session 状态的生命周期的， 在 v5.0 版本上，它把 CleanSession 拆分成两个部分，一个是 CleanStart，还有一个是 Session Expiry interval。CleanStart 用来决定建立连接时是否需要开始一个新的 Session 或者沿用之前已存在的 Session，如果 CleanStart 设为 1，就丢弃之前存在的 Session 并开启新的 Session。Session Expiry interval 用来表示断开连接后 Session 留存的时间。如果 Clean Start 被设为 1，Session Expiray interval 设为 0，就相当于 mqtt v3.1.1 中 Clean Session 设为 1。如果 Clean Start 设为 0，没有设置 Session Expiry Interval，那么就相当于 mqtt v3.1.1 中 Clean Session 设置为 0。

### Will Flag
Will Flag 若设为 1，那么 Will Message 必须存在服务器上，并且和 Session 关联起来，在 CONNECT Payload 字段中的 Will Message 包含了 Will Properties, Will Topic 以及 Will Payload 字段。 在网络连接断开并且 Will Delay interval 过期或者 Session 结束的时候　Will Message 必须发出来，除非在服务器收到 DISCONNECT 包之前就已经把 Will Message 删除了或者在 Will Delay Interval 过期前建立了新的网络连接。

在网络连接断开并且在 Session 结束，或者 Will Delay Interval 过期的时候，服务器都应该立即发布 Will Message。

其他基本和 V3.1.1 没什么差别

### Password Flag
在 v5.0 版的 MQTT 协议中，可以发送不带 User Name 的 Password。

### CONNECT Properties
#### Property Length
用不定长字节整形来编码的 Properties 长度
#### Session Expiry Interval
四个字节整形表示的Session Expiry Interval，单位是秒，如果这个属性在一个控制包中出现了两次，就会视为协议错误。

如果 Session Expiry Interval 设置为 0 或者没有设置，那么当网络连接关闭的时候 Session 就会结束。

如果 Sessoin Expiry Interval 设为 0xFFFFFFFF(UINT_MAX)，那么这个 Session 就不会过期。

如果 Session Expiry Interval 大于 0，那么 服务器和客户端在关闭网络连接的之后还要保存网络连接。

如果客户端只想在连接的时候处理消息，那么就需要把 Clean Start 设为 1，Session Expiry Interval 设为 0， 这样的话，在它建立连接之前，它不会收到任何已经发布的应用消息，并且需要在每次建立连接的时候重新订阅所有需要订阅的 Topic。

当客户端连接到服务器的网络非常不稳定的情况下，客户端可以设置一个较短的 Session Expiry Interval，以便它在网络恢复可用状态的时候重新建立连接并继续进行可靠的消息传输。若客户端没有重新连接，那么就让 Session 过期，然后丢失应用消息。

当客户端建立一个带有很长的 Session Expiry Interval 或者 Session 根本不会 过期的连接的时候，它会请求服务器在它断开连接后的很长一段时间内维护它的 MQTT Session。假如有客户端在之后的某个时间点需要重新和服务器建立连接的这种情况，客户端应该仅仅在这种情况下建立带有长 Session Expiry Interval 的连接。如果客户端决定将来不会在用到 Session 的时候，它就应该在断开连接的时候把 Session Expiry 设为 0。

客户端应该一直在 CONNACK 包中使用 Session Present flag去判断是否 Server 一直为该客户端维持 Session 状态。

客户端可以避开实现它自己的 Session expiry，它可以通过依赖服务器返回的 Session Present Flag 来判断 Session 是否到期。如果客户端实现了它自己的 Session expiry，那么它就需要存储 Session State 删除的时间作为它自己 Session 的一部分。

### Receive Maximum
33(0x21) 该属性仅仅只能在控制包中出现一次， 它是用 2 个字节的整形来表示的。客户端通过使用这个值来限制同时并行处理 QoS1 和 QoS2 消息。现在还没有机制来限制服务器可能会发布的 QoS0　消息。Receive Maximum 只会应用在当前网络连接中，如果没有设置 Receive Maximum，那么它就会设为默认值 65535。

### Maximum Packet Size
39(0x27)　该属性只能在一个 CONNECT 包中出现一次，它用 4 个字节的整形来表示，如果没有指定 Maximum Packet Size，那么就可能导致控制包大小超出协议的限制。

这里的 Packet Size 指的是整个 MQTT 控制包的所有字节数。客户端使用 Maximum Packet Size 来通知服务器，让它不要处理超过这个大小的数据包。

服务器不能发送超过 Maximum Packet Size 的包给客户端，如果客户端收到了超出限制的 Packet，那么会视为协议错误，并在断开连接的时候返回一个 0x95 （包太大）的 Reason Code 。

如果 Packet 太大以至于不能正常发送，那么服务器就需要丢弃那些 Packet 并且表现得好像已经完成应用消息发送那样。

在 Shared Subscription　下，有可能消息太大不能发送给部分客户端，但是另外一部分客户端可以接收到，服务器可以选择不向任何客户端发送消息并丢弃所有的消息，也可以只向那些可以接收到消息的客户端发送消息。

服务器可以把这些在发送前就被丢弃的 Packet 放到 dead letter 队列中， 或者执行其它诊断操作。

### Topic Alias Maximum
34(0x22)　该属性不可重复，由两字节表示，若未设定 Topic Alias Maximum，则就将其默认设为 0。

这个值是用来描述在客户端可以从服务器端那里接收的最多的 Topic Alias 数量，可以用来限制客户端在维持的 Topic Alias 数量。服务器在一个 PUBLISH packet 中发送的 Topic Alias 数量不能超过 Topic Alias Maximum。

若 Topic Alias Maximum 设为 0，则意味着客户端不会在本连接中接收任何 Topic Alias。如果 Topic Alias Maximum 被设为 0，也意味着服务器不会发送任何 Topic Aliases 给客户端。

### Request Response Information
25(0x19) 字节，Request Response Information 的 Identifier。
这个字节只能表示 0 或者 1，如果它表示的值是 0 或 1以外的值，或者该属性重复了，那么就会视为协议错误，若未指定 Request Response Information，则将其值设为默认值0。

客户端使用该值去请求服务器，服务器会在 CONNACK 包中返回 Response 信息。当 Request Response Information 设为 0 的时候，意味着服务器不应该返回响应信息了。如果值为 1，那么服务器会在 CONNACK 包中返回 Response Information。
服务器可以客户端请求 Response Information 的时候选择不在 CONNACK 中包含 Response Information。

### Request Problem Information


