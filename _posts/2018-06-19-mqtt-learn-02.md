---
title: mqtt 学习笔记(2)
date: 2018-06-28
category: 
- Mqtt
tags:
- erlang
- mqtt
- v5.0
---

# MQTT v3.1.1 diff MQTT v5.1

## 开头简介的变化
MQTT　5.0 协议相比 MQTT 3.1.1　变了很多，这里写一个笔记罗列一下，MQTT 5.0 Spec 中和 MQTT 3.1.1 Spec 中有哪些异同点。
 
新增关于 Shared Subscription（共享订阅） 的定义：
一个共享订阅由由一个 Topic Filter 和一个 QoS 最大值构成，Shared Subscription 可以关联多个 Session 用于更广泛的消息交换范式。匹配 Shared Subscription 的应用消息只会发送给与这些会话之一关联的客户端。一个会话可以订阅多个 Shared Subscription,也可以同时订阅 Shared Subscription 和非 shared Subscription。

新增 Malformed Packet 的定义描述：
无法被 parsed 的 Control Packet

新增 Protocol Error 的定义描述：
Control Packet 虽然被 parse 成功，但是它包含的数据违反了协议标准或者它与服务器和客户端的状态不一致, 这种情况需要作为 error 来处理。

新增 Will Message 的定义描述：
若网络连接非正常断开， 服务器需要发布的应用消息。

 MQTT v5.0 最主要的添加的几个最重要的新特性：
 * 增强了扩展性
 * 改善了错误报告的方式
 * 形式化了一些通用范式，比如说 capability 和 request response
 * 多了扩展机制，比如说用户属性(user properties)
 * 性能改善，并且添加了对 small clients 的支持

## MQTT 控制包格式上的变化
MQTT v5.0 中的控制包的结构大体上和之前 v3.1.1 是一模一样的，都是分为 Fixed header，Variable Header, Payload 三块。Fixed header 在所有 MQTT 控制包中都，后两者未必。
 
在 MQTT 控制包类型上有几点重要的变化:
1. DISCONNECT 包中数据流向并不仅仅是客户端到服务器，还包括服务器到客户端，功能上的也不再是表示 Client 正在断开连接，而是用来表示通知连接断开。
2. 最后一个 0x15 原本是预留位，在 MQTT v5.0 中这一位被用了起来，它这里从 Reserved 变为了 Auth，数据流向为双向的 client <-> server。用来表示认证的交换。

用来表示 Flag 的那四位，原本接收者收到无效的 Flags，会强制断开连接，在 v5.0 中会被视 Malformed Packet，等待进一步的错误处理。

关于 Packet Identifier　这里要注意一下：新添加的 AUTH 控制包类型是不包含 Packet Identifier 字段的。

MQTT v5.0 增加的一个最重要之一的一个东西就是 Properties。像CONNECT,CONNACK,PUBLISH,PUBACK,PUBREC.etc 这些包中 Variable Header 的最后一个字段都是一组 properties。在 CONNECT 包中，Payload 的 Will Properties 字段中也有一系列可选的 Properties 集。

property length 是用来描述 properties 长度的，这个长度不包含 properties length 它本身，如果没有 properties，那么就把 property length 设为 0。

下面列一下关于 properties 的用法，类型以及所在的控制包。
1 (0x01) Payload 格式指示器， 字节，位于 PUBLISH 控制包, Will properties中。
2 (0x02) Message 到期间隔，四字节整形，位于 PUBLISH 控制包, Will properties中。
3 (0x03) 内容类型，UTF-8 编码字符串，位于 PUBLISH 控制包, Will properties中。
8 (0x08) 响应 Topic，UTF-8 编码字符串，位于 PUBLISH 控制包, Will properties中。
9 (0x09) 关联数据，二进制数据，位于 PUBLISH 控制包, Will properties中。
11(0x0B) Subscription Identifier，它是  Variable Byte 整形，位于 PUBLISH 控制包, SUBSCRIBE 中。
17(0x11) Session 到期间隔，四字节整形，可以位于 CONNECT,CONNACK, DISCONNECT中。
18(0x12) 已分配的 Client Identifier，UTF-8 字符串，位于 CONNACK 中。
19(0x13) Server keep alive，两字节整形，位于 CONNACK 中。
21(0x15) Authentication Method（验证方法）， UTF-8 编码字符串，位于 CONNECT, CONNACK, AUTH 包中。
22(0x16) Authentication Data (验证数据)，二进制数据，，位于 CONNECT，CONNACK，AUTH 中。
23(0x17) Request Problem Information, 字节，位于 CONNECT 中。
24(0x18) Will Delay interval，四字节整形，位于 Will Properties。
25(0x19) Request Response Information, 字节，位于 CONNECT 中。
26(0x1A) Response Information， UTF-8 编码字符串，位于 CONNACK 中。
28(0x1C) Server Reference，UTF-8 编码字符串， 位于 CONNACK，DISCONNECT 中
31(0x1F) Reason String，UTF-8 编码字符串，位于 CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBACK, UNSUBACK, DISCONNECT, AUTH 包中。
33(0x21) Receive Maximum，两字节整形，位于 CONNECT,CONNACK 中。
34(0x22) Topic Alias Maximum，两字节整形，位于 CONNECT, CONNACK 中。
35(0x23) Topic Alias，两字节整形，位于 PUBLISH 包中。
36(0x24) Maximum QoS，字节，位于 CONNACK 包中。
37(0x25) Retain Available，字节，位于 CONNACK 包中。
38(0x26) User Property，UTF-8 字符串对，位于 CONNECT, CONNACK, PUBLISH, Will Properties, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK, DISCONNECT, AUTH。
39(0x27) Maximum Packet Size，四字节整形，位于 CONNECT,CONNACK 包中。
40(0x28) Wildcard Subscription, 字节，位于 CONNACK 包中。
41(0x29) Subscription Identifier Available，字节，位于　CONNACK 包中。
42(0x2A) Shared Subscription Available，字节，位于 CONNACK 包中。

虽然 Property Identifier 被定义为 Variable Byte Integer，但是在这个版本的 mqtt 中，Property Identifier 长度都不会超过一个字节。

关于 Payload，和 v3.1.1 不同，在 v3.1.1 中，UNSUBACK 包中不包含 Payload，而在 5.0 的版本中，UNSUBACK 包包含 Payload，新引入的 AUTH 包不包含 Payload。

MQTT v5.0 中新引入了一个东西叫 Reason Code。它是用来表明操作结果的一个单字节无符号值，小于 0x80的 Reason Codes 表明操作的结果是成功的，正常的成功操作返回的 Reason Code 值为 0。 如果返回的 Reason Code 大于等于 0x80，就说明操作失败了。

CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, DISCONNECT 和 AUTH 控制包有单个 Reason Code 作为一部分在Variable Header 中。而 SUBACK 和 UNSUBACK 包在 Payload 中包含了一张一个或多个 Reason Codes 的列表。

以下的 Reason Codes 一览列表:
0    0x00             Success                      ; CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, UNSUBACK, AUTH
0    0x00       Normal disconnection               ; DISCONNECT
0    0x00          Granted QoS 0                   ; SUBACK
1    0x01          Granted QoS 1                   ; SUBACK
2    0x02          Granted QoS 2                   ; SUBACK
4    0x04    Disconnect with Will Message          ; DISCONNECT 
16   0x10     No matching subscribers              ; PUBACK,PUBREC
17   0x11      No subscription existed             ; UNSUBACK
24   0x18      Continue authentication             ; AUTH
25   0x19          Re-authenticate                 ; AUTH
128  0x80          Unspecified error               ; CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT
129  0x81          Malformed Packet                ; CONNACK, DISCONNECT
130  0x82           Protocol Error                 ; CONNACK, DISCONNECT
131  0x83  Implementation specific error           ; CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT
132  0x84  Unsupported Protocol Version            ; CONNACK
133  0x85   Client Identifier not valid            ; CONNACK
134  0x86     Bad User Name or Password            ; CONNACK
135  0x87           Not authorized                 ; CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT
136  0x88       Server unavailable                 ; CONNACK
137  0x89            Server busy                   ; CONNACK, DISCONNECT
138  0x8A              Banned                      ; CONNACK
139  0x8B       Server shutting down               ; DISCONNECT
140  0x8C       Bad authentication method          ; CONNACK, DISCONNECT
141  0x8D         Keep Alive timeout               ; DISCONNECT
142  0x8E         Session taken over               ; DISCONNECT
143  0x8F         Topic Filter invalid             ; SUBACK,UNSUBACK,DISCONNECT
144  0x90         Topic Name invalid               ; CONNACK, PUBACK, PUBREC, DISCONNECT
145  0x91       Packet Identifier in use           ; PUBACK, PUBREC, SUBACK, UNSUBACK
146  0x92    Packet Identifier not found           ; PUBREL,PUBCOMP
147  0x93    Receive Maximum exceeded              ; DISCONNECT
148  0x94    Topic Alias invalid                   ; DISCONNECT
149  0x95      Packet too large                    ; CONNACK, DISCONNECT
150  0x96      Message rate too high               ; DISCONNECT
151  0x97          Quota exceeded                  ; CONNACK, PUBACK, PUBREC, SUBACK, DISCONNECT
152  0x98       Administrative action              ; DISCONNECT
153  0x99      Payload format invalid              ; CONNACK,PUBACK, PUBREC, DISCONNECT
154  0x9A      Retain not supported                ; CONNACK,DISCONNECT
155  0x9B       QoS not supported                  ; CONNACK,DISCONNECT
156  0x9C      Use another server                  ; CONNACK,DISCONNECT
157  0x9D     Server moved                         ; CONNACK,DISCONNECT
158  0x9E      Shared Subscriptions not supported  ; SUBACK, DISCONNECT
159  0x9F     Connection rate exceeded             ; CONNACK,DISCONNECT
160  0xA0     Maximum connect time                 ; DISCONNECT
161  0xA1  Subscription Identifiers not supported  ; SUBACK, DISCONNECT
162  0xA2   Wildcard Subscriptions not supported   ; SUBACK, DISCONNECT

对于 0x91 的 Reason Code ，对于它的响应应该是尝试修复状态，或者通过使用 Clean Start 设为 1 来重置 Session 状态，或者判断 Client 和 Server 的实现是否是有缺陷的。

# MQTT 控制包的变化
## CONNECT 包

在 v5.0 中，CONNECT 包有以下几个地方发生了变化。


### CleanStart
第一个是 Protocol Level 那里改成了版本 0x05。第二个是原来的 CleanSession 改为了 CleanStart。
CleanSession 是用来控制 Session 状态的生命周期的， 在 v5.0 版本上，它把 CleanSession 拆分成两个部分，一个是 CleanStart，还有一个是 Session Expiry interval。CleanStart 用来决定建立连接时是否需要开始一个新的 Session 或者沿用之前已存在的 Session，如果 CleanStart 设为 1，就丢弃之前存在的 Session 并开启新的 Session。Session Expiry interval 用来表示断开连接后 Session 留存的时间。如果 Clean Start 被设为 1，Session Expiray interval 设为 0，就相当于 mqtt v3.1.1 中 Clean Session 设为 1。如果 Clean Start 设为 0，没有设置 Session Expiry Interval，那么就相当于 mqtt v3.1.1 中 Clean Session 设置为 0。

如果 Clean Start 设为 1　那么响应的 CONNACK 包中的 Session Present flag　一般就会设定为 0 了。

### Will Flag
Will Flag 若设为 1，那么 Will Message 必须存在服务器上，并且和 Session 关联起来，在 CONNECT Payload 字段中的 Will Message 包含了 Will Properties, Will Topic 以及 Will Payload 字段。 在网络连接断开并且 Will Delay interval 过期或者 Session 结束的时候　Will Message 必须发出来，除非在服务器收到 DISCONNECT 包之前就已经把 Will Message 删除了或者在 Will Delay Interval 过期前建立了新的网络连接。

在网络连接断开并且在 Session 结束，或者 Will Delay Interval 过期的时候，服务器都应该立即发布 Will Message。

其他基本和 V3.1.1 没什么差别

### Password Flag
在 v5.0 版的 MQTT 协议中，可以发送不带 User Name 的 Password。

### CONNECT Properties
#### Property Length
用不定长字节整形来编码的 Properties 长度
#### Session Expiry Interval
17(0x11)  四个字节整形表示的Session Expiry Interval，单位是秒，如果这个属性在一个控制包中出现了两次，就会视为协议错误。

如果 Session Expiry Interval 设置为 0 或者没有设置，那么当网络连接关闭的时候 Session 就会结束。

如果 Sessoin Expiry Interval 设为 0xFFFFFFFF(UINT_MAX)，那么这个 Session 就不会过期。

如果 Session Expiry Interval 大于 0，那么 服务器和客户端在关闭网络连接的之后还要保存网络连接。

当会话过期时，客户端和服务器不需要以原子方式处理状态的删除。

如果客户端只想在连接的时候处理消息，那么就需要把 Clean Start 设为 1，Session Expiry Interval 设为 0， 这样的话，在它建立连接之前，它不会收到任何已经发布的应用消息，并且需要在每次建立连接的时候重新订阅所有需要订阅的 Topic。

当客户端连接到服务器的网络非常不稳定的情况下，客户端可以设置一个较短的 Session Expiry Interval，以便它在网络恢复可用状态的时候重新建立连接并继续进行可靠的消息传输。若客户端没有重新连接，那么就让 Session 过期，然后丢失应用消息。

当客户端建立一个带有很长的 Session Expiry Interval 或者 Session 根本不会过期的连接的时候，它会请求服务器在它断开连接后的很长一段时间内维护它的 MQTT Session。假如有客户端在之后的某个时间点需要重新和服务器建立连接的这种情况，客户端应该仅仅在这种情况下建立带有长 Session Expiry Interval 的连接。如果客户端决定将来不会在用到 Session 的时候，它就应该在断开连接的时候把 Session Expiry 设为 0。

客户端应该一直在 CONNACK 包中使用 Session Present flag去判断是否 Server 一直为该客户端维持 Session 状态。

客户端可以避开实现它自己的 Session expiry，它可以通过依赖服务器返回的 Session Present Flag 来判断 Session 是否到期。如果客户端实现了它自己的 Session expiry，那么它就需要存储 Session State 删除的时间作为它自己 Session 的一部分。

#### Receive Maximum
33(0x21) 该属性仅仅只能在控制包中出现一次， 它是用 2 个字节的整形来表示的。客户端通过使用这个值来限制同时并行处理 QoS1 和 QoS2 消息数量。现在还没有机制来限制服务器可能会发布的 QoS0　消息。Receive Maximum 只会应用在当前网络连接中，如果没有设置 Receive Maximum，那么它就会设为默认值 65535。值被设为0 或者该属性重复会引发协议错误。

#### Maximum Packet Size
39(0x27)　该属性只能在一个 CONNECT 包中出现一次，它用 4 个字节的整形来表示，如果没有指定 Maximum Packet Size，那么就可能导致控制包大小超出协议的限制。值被设为0 或者该属性重复会引发协议错误。

这里的 Packet Size 指的是整个 MQTT 控制包的所有字节数。客户端使用 Maximum Packet Size 来通知服务器，让它不要处理超过这个大小的数据包。

服务器不能发送超过 Maximum Packet Size 的包给客户端，如果客户端收到了超出限制的 Packet，那么会视为协议错误，并在断开连接的时候返回一个 0x95 （包太大）的 Reason Code 。

如果 Packet 太大以至于不能正常发送，那么服务器就需要丢弃那些 Packet 并且表现得好像已经完成应用消息发送那样。

在 Shared Subscription　下，有可能消息太大不能发送给部分客户端，但是另外一部分客户端可以接收到，服务器可以选择不向任何客户端发送消息并丢弃所有的消息，也可以只向那些可以接收到消息的客户端发送消息。

服务器可以把这些在发送前就被丢弃的 Packet 放到 dead letter 队列中， 或者执行其它诊断操作。

#### Topic Alias Maximum
34(0x22)　该属性不可重复，由两字节表示，若未设定 Topic Alias Maximum，则就将其默认设为 0。

这个值是用来描述在客户端可以从服务器端那里接收的最多的 Topic Alias 数量，可以用来限制客户端在维持的 Topic Alias 数量。服务器在一个 PUBLISH packet 中发送的 Topic Alias 数量不能超过 Topic Alias Maximum。

若 Topic Alias Maximum 设为 0，则意味着客户端不会在本连接中接收任何 Topic Alias。如果 Topic Alias Maximum 被设为 0，也意味着服务器不会发送任何 Topic Aliases 给客户端。

#### Request Response Information
25(0x19) 字节，Request Response Information 的 Identifier。
这个字节只能表示 0 或者 1，如果它表示的值是 0 或 1以外的值，或者该属性重复了，那么就会视为协议错误，若未指定 Request Response Information，则将其值设为默认值0。

客户端使用该值去请求服务器，服务器会在 CONNACK 包中返回 Response 信息。当 Request Response Information 设为 0 的时候，意味着服务器不应该返回响应信息了。如果值为 1，那么服务器会在 CONNACK 包中返回 Response Information。
服务器可以在客户端请求 Response Information 的时候选择不在 CONNACK 中包含 Response Information。

#### Request Problem Information
23(0x17) 字节。和 Request Response Information 一样，值只能设为 0　或 1，不可重复，但是若不设定 Request Problem Information,那么就会用默认值 1。

客户端通常使用这个值来在失败的情况下表明是否 Reason String 或 User Properties 被发送了。

如果 Request Problem Information 的值被设为 0，服务器可以在 CONNACK 或 DISCONNECT 包中返回一个 Reason String 或　User Properties。但是不能发送 Reason String或 User Properties 在其它任何包中，PUBLIHS, CONNACK 或 DISCONNECT 包除外。如果值设为 0，而 客户端却在 PUBLISH,CONNACK,DISCONNECT 包以外收到了 Reason String 或 User Properties,  那么就应该用一个带有 Reason Code 0x82（协议错误） 的 DISCONNECT 包去断开连接。

如果值设为 1，那么服务器就可以在任何被允许的包中返回　Reason String 或 User Properties。
 
#### User Property
38(0x26), User Property 的 Identifier。
User Property 可以出现多次，也可以代表多个 name, value pairs。同样的名字，name 可以重复出现多次。

在 CONNECT 包中的 User Properties 在客户端发送到服务器的过程中可以被用来发送和连接相关的属性。

#### Authentication Method
21(0x15) 字节，Authentication  Method 的 Identifier。
它是一个UTF-8编码字符串，其中包含用于扩展身份验证的身份验证方法的名称。Authentication Method 只能出现一次，如果没有设置Authentication Method 的话，扩展身份验证就无法继续被执行下去。

如果在 CONNECT 包中设置 Authentication Method，那么客户端在收到 CONNACK 包之前除了发送 AUTHO 或 DISCONNECT 包以外就不能发送任何包。

#### Authentication Data
22(0x16)
它是包含 authentication 数据的二进制数据。这个属性只能出现一次如果包含 Authentication Data 属性的时候不包含 Authentication Method 就会视为协议错误。

该数据的内容在 authentication method 中定义。

### Variable Header 的例子
在 v3.1.1 的 CONNECT 包的 Variable header 中，可以只占用　10 个字节，而在 v5.0 的 CONNECT 包的 Variable Header 中，至少也要占用 16 个字节。
v5.0 CONNECT 的 Variable Header 的前面 10 个字节与 v3.1.1 大抵相同，只是在版本号上和 CleanSession 改为了 CleanStart这两处改了。

后面新添加的 6 个字节都是 Properties。
字节 11 是 Length。
字节 12 是 Session Expiry Interval 的 Identifier
字节 13，14，15，16　是 Session Expiry Interval。


### CONNECT Payload
v5.0 CONNECT 中的 Payload 主要增加了 Will Properties，其它的都是细微的调整。
#### Client Identifier
v5.0 这里服务器会多一个步骤，它在处理 CONNECT 包之后还要在 CONNACK 包中返回已分配的 Client Identifier。
因为v5.0 中已经没有了 CleanSession，所以这里客户端不需要对 CleanSession 做额外的处理。
如果服务器拒绝了 Client Id，它可能会使用带 Reason Code 0x85(Client Identifier 无效)来响应 CONNECT 包，然后处理错误，关闭网络连接。

#### Will Properties
如果 Will Flag 设为 1，Will Properties 就会是 Payload 中的下一个字段。Will Properties 字段是用来定义当消息被发布的时候会和 Will Message 一起发送的 Application Message  Properties 以及何时发布 Will Message 的属性。

Will Properties 主要有这几种： Property Length，Will Delay Interval, Payload Format Indicator, Message Expiry Interval, Content Type, Response Topic, Correlation Data, User Property。

##### Property Length 
与上述 CONNECT Properties 中的 Property Length 相同。

##### Will Delay Interval 
24(0x18) 与 CONNECT Property　中的 Session Expiry Interval 比较相似，都由四字节整形来表示 Will Delay Interval ,　Will Delay Interval 只能出现一次。如果没有设置 Will Delay Interval，那么 Will Delay Interval 的默认值为 0，也就意味着 Will Message 的发布不会有延迟。

服务器只有在 Will Delay Interval 过期或者 Session 结束的时候才可以发布客户端的 Will Message。如果在 Will Delay 过期之前在这个会话上建立了一个新的网络连接，那么服务器就不应该再发送任何 Will Message 了。

Will Delay Interval 其中一个用途是在临时网络断开并且客户端在Will Message发布之前成功地重新连接并继续其会话的情况下避免发布Will Messages。

如果网络连接使用了已存在的到服务器的网络连接的 Client Identifier，那么已存在的连接中的 Will Message 就会被发送，除非新的连接指明了 Clean Start 为 0 且 Will Delay 大于 0。如果 Will Delay 是 0，那么 Will Message 就会在已存在的网络连接关闭的时候发送出去，如果 Clean Start 设置为 1，那么 Will Message 会因为 Session 结束。

##### Payload Format Indicator
1(0x01) 字节。
当该属性值为 0（0x00） 的时候，意味着 Will Message 是未确定的字节，相当于不发送 Payload Format Indicator。
当该属性值为 1（0x01） 的时候，意味着 Will Message 是 UTF-8 的字符数据，在 Payload 中的 UTF-8 数据必须是由 Unicode  规范定义的格式良好的 UTF-8 数据。
该属性只能出现一次，服务器会验证 Will Message 是不是 Payload Format Indicator。如果不是，就会发送一个带有Reason Code 为 0x99 （Payload 格式无效）的 CONNACK 包。

##### Message Expiry Interval
2(0x02) 字节。
该属性由 4 字节整形来表示 Message Expiry Interval。它只能出现一次。
如果存在该属性，那么这个 4 字节的值就表示 Message Expiry Interval 的长度，单位是秒。当服务器发布 Will Message 的时候， Message Expiry Interval 会作为 Publication Expiry Interval 来发送。

如果不存在该属性，那么服务器在发布 Will Message 的时候就不会再发送 Message Expiry Interval

##### Content Type
3 (0x03)
该属性是用来描述 Will Message 内容的，用 UTF-8 来编码字符串，只能出现一次，Content Type 的值由收发的应用来定义。

##### Response Type
8 (0x08)
UTF-8 编码的字符串，通常是用来作为响应消息中的 Topic Name，只能出现一次，若 Response Topic 存在，会将 Will Message 视为一个请求。

##### Correlation Data
9 (0x09)
二进制数据， 该数据通常是给请求消息的发送者中用来鉴别哪一个才是它收到的响应消息的请求。该属性只能出现一次。如果没有设定 Correlation Data，那么请求者就不需要任何 correlation Data。

##### User Property 
38(0x26)
与 CONNECT properties 基本相同，需要注意的是，　在发布　Will Message 的时候， 服务器必须维护作为 Will Property 的 User Properties的次序。
该服务器用于给传输应用层提供一个 name-value 标签，该标签仅由负责收发的应用程序来解释和了解。

#### Will Topic
Will Topic 没变。

#### Will Payload
v3.1.1 中的 Will Message 变为了 v5.0 中的 Will Payload。区别在于 Will Payload 和 Will Message 的构成不一样了，Will  Payload 字段仅由二进制数据构成。

#### User Name  & Password
User Name 和 v3.1.1 没有任何区别，Password 这里主要是它相比 v3.1.1 更简化了，这个字段是纯粹的二进制数据构成，并且虽然它名称为 Password，却还可以存放任何类型的数字证书。

### CONNECT Actions
在 CONNECT 行为这里，需要注意的是：如果服务器在验证 CONNECT 包格式的时候匹配失败的话，还需要先发送一个带有大于等于 0x80  Reason Code 的 CONNACK 包，然后再断开连接，v3.1.1 中 没有发送 CONNACK 包这一步。

v5.0 中如果 Server 检查 CONNECT 包失败的话，也需要先发送一个带有大于等于 0x80  Reason Code 的 CONNACK 包，再断开连接。

如果验证成功了，服务器还要执行以下几步：
1.检查 ClientID 是否重复，若重复则发送带有大于等于 0x80  Reason Code 的DISCONNECT包，然后断开连接
2.执行 Clean Start 的处理
3.必须用带有 0x00 (Success) Reason Code 的 CONNACK 包去确认 CONNECT 包。
注：如果服务器被用于处理关键的商业数据，还需要执行验证和授权检查。如果检查通过，服务器会通过发送 Reason Code 为 0x00(Success) 的 CONNACK 包来响应。如果失败的话，就不会发送 CONNACK 包了，因为这可能会提醒潜在的攻击者存在MQTT服务器，并鼓励此类攻击者发起拒绝服务或猜测密码攻击。
 
4.开始传输消息，并且保持监控状态。

在 v5.0 协议中，假如服务器拒绝了 CONNECT 包，它就不能再处理 Client 之后发送的任何数据，AUTH 包除外。

注： 5.0 协议中需要多注意两点
 1. 收到 CONNACK 包之前发送 MQTT 控制包的客户端将不会知道服务器的限制以及是否有已经存在的会话已经被使用了，
 2. 如果服务器在验证完成前发送了太多的数据，服务器可以限制网络连接的读取或者关闭网络连接。这是用来对抗

##  CONNACK-连接确认
此包用于响应 CONNECT 包，除非是 Auth 包，否则其它任何情况下，服务器都应该发包前发送带有 0x00(Success) Reason Code CONNACK包在一次连接中不能重复发多份 CONNACK 包。
Fixed　Header 相比 v3.1.1 没有更改，Variable 多了两字段：Connect Reason　Code 和 Properties。
Variable　Header 中的第一个字节，除了第 0 位是用来表示Session Present ，其它 7-1 位都是预留位。
CONNACK 没有 Payload。
### Connect Acknowledge Flags

#### Session Present
由于v5.0 版本中 Clean Session 的取消以及新设了 Clean Start。所以 Session Present 的行为也变了。
如果服务器接收了 Clean Start 设为 1的连接，服务器就必须把 CONNACK Session Present 置为 0，并且在 CONNACK 包中把 Reason Code 设为 0x00。反之，将 Session Present 设为 1，无论是哪种情况都必须在 CONNACK 中的 Reason Code 设为 0x00。

如果客户端从服务器收到的 Session State 与预期不符，那么就应该关闭网络连接，如果 Session Present 设为  0 而客户端有 Session State，那么 Client 在断开网络前还必须先主动丢弃 Session State。

#### Connect Reason Code
0    0x00            Success                 ; 接受连接
128  0x80          Unspecified error         ; 服务器无意揭示失败原因或者其它 Reason Code 无法解释该错误原因。
129  0x81          Malformed Packet          ; CONNECT 包中的数据无法被正确 Parse
130  0x82           Protocol Error           ; CONNECT 包中的数据与协议标准不一致
131  0x83  Implementation specific error     ; CONNECT 包有效但是没有被服务器接受
132  0x84  Unsupported Protocol Version      ; 服务器不支持客户端传来的 MQTT 包的协议标准。
133  0x85   Client Identifier not valid      ; Client Identifier 是一个有效字符串但却没有被服务器接收
134  0x86     Bad User Name or Password      ; 服务器不接受客户端指定的用户名和密码
135  0x87           Not authorized           ; 客户端没有被授权去连接
136  0x88       Server unavailable           ; MQTT 服务器不可用
137  0x89            Server busy             ; 服务器繁忙，之后重试
138  0x8A              Banned                ; 客户端被管理员 ban 了，需要联系管理员
140  0x8C       Bad authentication method    ; 不支持验证方法, 或无法匹配当前验证方法
144  0x90         Topic Name invalid         ; Will Topic Name 的格式没有问题但不被服务器接收
149  0x95      Packet too large              ; 包的大小超过了允许的最大值
151  0x97          Quota exceeded            ; 超出实现或管理的限制
153  0x99      Payload format invalid        ; Will Payload 没有匹配到指定的 Payload Format Indicator。
154  0x9A      Retain not supported          ; 服务器不支持 Retained 消息且 Will Retain 设为了 1
155  0x9B       QoS not supported            ; 服务器不支持在 Will QoS 中设置的 QOS 等级。
156  0x9C      Use another server            ; 客户端应该暂时使用另一台服务器。
157  0x9D     Server moved                   ; 客户端应该使用另一台服务器。
159  0x9F     Connection rate exceeded       ; 超出连接速率的限制。
服务器在发送 CONNACK 都必须带有以上 Reason Code 的其中一个。

#### CONNACK　Properties
##### Property Length
同 CONNECT 的 Properties Length
##### Session Expiry Interval
同 CONNECT 中的 Session Expiry Interval，只不过 CONNACK 包中的 Session Expiry Interval 是服务器用来通知客户端它使用的一个与 Client 中 Session Expiry Interval 不同的值。

##### Receive Maximum
同 CONNECT 中的 Receive Maximum

##### Maximum QoS
36(0x24)。
该属性占一个字节，仅能表示 1 或者 0 两个值，只能出现一次。如果没有设定该属性，客户端就会使用 QoS 为 2 的值。
如果服务器不支持 QoS1 或 QoS2 的 PUBLISH 包，那它就必须在 CONNACK 包中说明它支持的最高 QoS，不支持 QoS1 或 QoS2 的 PUBLISH 包的服务器仍需接受包含 QoS,0,1,2 的 SUBSCRIBE 包。

客户端从服务器那里收到 Maximum QoS 后，就不能再发送超出那一 QoS 等级的 PUBLISH 包了，否则将视为 Protocol Error ，通过发送一个带有 Reason Code　0x9B（QoS 不支持） 的 DISCONNECT 包来处理错误。如果收到的 CONNECT 包中 Will QoS 的 QOS 也超出那一限制，就会将其视为 Protocol Error，并发送一个带有 Reacon Code 0x9B 的 CONNACK 包来处理错误。

##### Retain Avaliable
37(0x25)
该属性占据一个字节，用来声明是否服务器支持 retained message，0 代表不支持， 1 代表支持，如果不设定该属性，则代表支持，如果该属性重复出现或表示的值不是 0 或 1，那就会触发 Protocol Error。

如果服务器收到一个包含 Will Retain 为 1 的 Will Message 的 CONNCT 包，且它不会支持任何 retained messages，服务器必须拒绝连接请求。它应该发送一个带有 Reason Code 0x9A (不支持 Retain )的 CONNACK 包然后它必须关闭连接。

##### Maximum Packet Size
同 CONNECT 的 Maximum Packet Size

##### Assigned Client Identifier
18（0x12）
Assigned Client Identifier  是一个 UTF-8 的字符串，只能出现一次，如果服务器发现客户端发来的 CONNECT 包中的 Client Identifier 长度为 0，那么就需要通过返回一个带有新的  Assigned Client Identifier 的 CONNACK 包来分配 Client Identifier 给客户端。

##### Topic Alias Maximum
同 CONNECT 的 Topic Alias Maximum

##### Reason String
31(0x1F)
使用 UTF-8 相关的编码字符串来表示， 该字符串是人类可读的字符串，并且不应该被客户端 parse，该属性通常都是用来向客户端提供额外诊断信息的，如果服务器增加该属性会使 CONNACK 包的大小超出客户端指定的 Maximum Packet Size，那么就不应该发送该属性。该属性只能包含一次。

##### User Property
38(0x26)
和 Reason String 非常相似，不过它包含的是一个 UTF-8 的 String Pair。并且可以出现多次，甚至相同的 String Pair 也能出现多次。包含接收者可以忽略 CONNACK 包中的该属性。

##### Wildcard Subscription Available
40(0x28)
该属性是用来声明是否服务器支持通配符订阅，值为 0 表示不支持，值为 1 表示支持，如果没有设定该属性则表示支持，该属性只能出现一次且不能出现 0 或 1 以外的值。
如果服务器收到一个包含 Wildcard Subscription 的 SUBSCRIBE 包的订阅，并且它不支持通配符订阅，那么就会发生 Protocol Error，服务器会在 DISCONNECT 包中放一个 Reason Code 0xA2(Wildcard Subscription no supported) 返回。
如果服务器支持 Wildcard Subscription，它仍可以拒绝带有通配符订阅的 particular 订阅，在这种情况下，服务器需要发送一个带有 Reason Code 0xA2 的 SUBACK 控制包。

##### Subscription Identifiers Available
41(0x29)
如果存在该属性，该属性是用来表示服务器是否支持 Subscription Identifiers。0 表示支持，1 表示不支持，如果不存在该属性，会将其看做支持来处理，该属性只能出现一次，它的值只能是 0 或 1。
如果服务器收到一个包含 SUBSCRIBE　Identifier 的 SUBSCRIBE 包但是该服务器不支持 Subscription Identifiers，那么就会将其视为协议错误。服务器会返回一个带有 Reason Code 0xA1 的 DISCONNECT 包。

##### Shared Subscription Available
42(0x2A)
如果设定了该属性，其值为 0，意味着不支持 Shared Subscriptions，如果设定了该 Identifier，其值为 1，意味着支持 Shared Subscriptions，如果没有设定该属性，默认表示支持。该属性不能重复出现，且其值不能为 0 或 1 以外的数字。
行为基本上和 Subscriptions Identifiers Available 行为一致。

##### Server Keep Alive
19(0x13)
该属性是用 2 个字节整形表示，带有 Keep Alive time ，由服务器分配。如果服务器在 CONNACK 包中发送了一个 Server Keep Alive，那么客户端必须使用该值而非客户端发送的 CONNECT 包中的 Keep Alive value。如果服务器不发送 Server Keep Alive，那么服务器就必须使用客户端在 CONNECT 包中设置的 Keep Alive 值。该属性只能出现一次。

Server Keep Alive的主要用途是让服务器通知客户端，它将断开与客户端的连接，断开时间要早于客户端中指定的 Keep Alive 值。

##### Response Information
26(0x1A)
该属性是一个 UTF-8 编码的字符串，是创建 Response Topic 的基础。但是客户端如何从 Response Information 去创建一个 Response Topic 不在该属性中定义。该属性只能出现一次。

如果服务器发送了一个值为 1　的 Request Response Information，对于服务器而言在不在 CONNACK 中发送 Response Information 可选的。

##### Server Reference
28(0x1C)
该属性是给客户端来用的，它是一个 UTF-8 编码的字符串，用于识别要使用的另外一个服务器。该属性只能出现一次。

##### Authentication Method
21(0x15)
该属性是一个包含了 authentication method 的一个 UTF-8 编码的字符串该属性只能出现一次。

##### Authentication Data
22(0x16)
该属性是一个包含 authentication 数据的二进制数据块。该数据的内容由 authentication 方法以及已交换的 authentication data 的状态来定义的。该属性只能出现一次。


## PUBLISH-(发布消息)

### Fixed Header
v5.0 的 Fixed Header 与 v3.1.1 的大同小异，因为 Reason Code 的引入，其他行为表现也改变了不少：

#### QoS
 在因为 QoS 而断开连接的时候，如果是因为收到的 PUBLISH 包中的 QoS 超过了 CONNACK 包中设定的 QoS 的最大值，服务器就会发送一个带有 0x9B(不支持该 QoS)来 DISCONNECT 包来断开连接。Reason Code 是用来帮助处理错误的。

 PUBLISH 包中的描述 QoS 那两位不能都用 1 表示，如果服务器或客户端收到了一个 QoS 位都设为 1 的 PUBLISH 包，那么这个包就会被视为 Malformed 包，服务器或客户端会使用带有 Reason Code 0x81(Malformed Packet)的 DISCONNECT 包去断开连接。
3. 在 v5.0 中，RETAIN flag 的作用也有了一些变化。

#### RETAIN
　　如果客户端发送给服务器的 PUBLISH 包中的 RETAIN flag 设为了 1，那么服务器就必须为该 topic 替换任何已存的 retained message 并且存储 Application Message，这样做是为了传递给未来会订阅该主题的订阅者。如果 Payload 长度为 0 字节，那么它会被服务器正常地处理，但是带有相同 topic name 的 retained message 会被移除，未来订阅该主题的订阅者也不会再收到该主题的 retained message，不包含 Payload 信息的 retained message 是无法作为 retained message 存储在 Server 上的。
　　如果 PUBLISH 包中的 RETAIN flag 设为 0，则服务器既不能存储消息作为 retained message，也不能移除或替换已存的 retained message。
如果允许存储 Retained Message 的服务器给 retained flag 为 0 的客户端发送了一个 CONNACK 响应，并且它收到了一个 RETAIN flag 设为 1 的PUBLISH包，那么它就会用 DISCONNECT REAON Code(不支持 Retain)去断开连接。
　　当一个新的非共享订阅被创建成功，最后的 retained message 会由 Retain Handling Subscription Option 来直接传给每个匹配订阅主题的客户端。这些消息中的 RETAIN Flag 会被设为 1。具体到发送哪一个 retained message 会由 Retain Handling Subscription Option 来控制。
　　以下是 Retain Handling 的选项说明：
   1. 如果 Retain Handling 被设为 0，那么服务器就必须发送匹配订阅 Topic Filter 的 retained message 给客户端。
   2. 如果 Retain Handling 被设为 1，那么如果订阅已经不存在了，服务器就必须发送所有匹配订阅 Topic Filter 的 retained message 给客户端，如果订阅还在，服务器就不要发送了 retained messages 了。
   3. 如果 Retain Handling 被设为 2，服务器不应该发送 retained message。

若服务器接收到 RETAIN flag 设为 1，QoS 设为 0 的 PUBLISH 包，那它就应该为该主题存储新的 QoS 为 0 的 message 作为新的 retained message，它也可以选择在任意时刻丢弃这条消息，但是这样一来该主题下就不会有任何留存的消息了。

若现在为某个主题留存的消息过期了，那么它就会被丢弃，那个主题下也不会再有 retained message 了。

在已建立的连接中，从服务器发来的应用消息中的 RETAIN flag 的设置由保留为已发布订阅的的选项来控制。

* 如果保留为已发布订阅的的选项的值设为 0，服务器就必须发送匹配到 Topic Filter 的 retained message　给客户端。
* 如果保留为已发布订阅的的选项的值设为 1，服务器就必须将 RETAIN flag 的值设为和收到的 PUBLISH 中 RETAIN flag 一样的值。

当发布者在一个非正常状态下发送状态消息的情况下，Retained message 是非常有用的，一个新的非共享订阅者将会收到它的最近的状态信息。

### Variable Header
v5.1 中的 PUBLISH Variable Header 中相比 v3.1.1 多了 Properties 字段。

Topic Name 和 Packet Identifier 新旧版本完全一致。

主要还是多了一堆属性。

#### Property Length
由可变字节整形来编码。
#### Payload Format Indicator
基本结构和之前描述的 Payload Format Indicator基本一致，需要额外注意的是:服务器必须要将未改变的 Payload Format Indicator 发送给接收该应用消息的所有用户，接收者可以验证 Payload 是否是指定格式，是否发送 PUBACK，PUBREC, 或带有 0x99(Payload 格式无效) Reason Code 的 DISCONNECT 包。

#### Message Expiry Interval
结构同之前描述的 Payload Format Indicator 一致，需要额外注意的是：如果 Message Expiry Interval 已经到期，而服务器尚未开始设法将消息传递给匹配的订阅者，那么它就必须删除该用户的消息拷贝。

由服务器发送给客户端的 PUBLISH 包必须包含一个 Message Expiry Interval，　这个 Message Expiry Interval 的值为接收到的值减去应用消息在服务器等待的时间。

#### Topic Alias
35(0x23)。
由两字节整形来表示 Topic Alias 的值。该属性只能出现一次。

Topic Alias 是一个整形的值，用来标识 Topic 而非使用 Topic Name。它可以减少 PUBLSIH 包的大小。当 Topic Name 很长，且在同一个网络连接中，Topic Names 会经常重复出现，这个时候就可以用到 Topic Alias 来减少网络带宽消耗。

发送者来决定是否使用 Topic Alias 以及选择 Topic Alias 的值，它通过包含一个非零长度的 Topic Name 和一个 Topic Alias 来在 PUBLISH 包中设置一个 Topic Alias 的映射，接收者按正常方式处理PUBLISH，但也将指定的 Topic Alias 映射设置为此主题名称。

如果 Topic Alias 映射已经在接收者那里设定过，那么发送者就可以发送一个包含 Topic Alias 和一个 0 长度 Topic Name 的 PUBSLIH 包。接收者会把收到的 PUBLISH 包当作一个包含 Topic alias 的 Topic Name 来处理。

发送者可以通过发送另一个在同一网络中，带有同一 Topic Alias 值以及一个不同的非零长度 Topic Name的 PUBLISH 包来修改 Topic Alias 映射。

Topic Alias 只会在有网络连接的时候存在，并且生命周期与网络连接一致，接收者不能把 Topic Alias 映射从一个网络连接带往另一个网络连接。

发送者不应该发送一个包含 Topic Alias 值为 0 的 PUBLISH 包。

客户端不能发送一个带有 Topic Alias 大于服务器在 CONNACK 包中返回的 Topic Alias Maximum　的 PUBLISH 包。客户端必须接收所有服务器在 CONNECT 包发送的 topic Alias 大于 0 且小于等于 Topic Alias Maximum 的值。

服务器不能发送一个带有 Topic Alias 大于客户端在 CONNACK 包中返回的 Topic Alias Maximum　的 PUBLISH 包。服务器必须接收所有客户端在 CONNECT 包发送的 topic Alias 大于 0 且小于等于 Topic Alias Maximum 的值。

服务器和客户端使用的 Topic Alias　映射是互相独立的。因此，假如客户端给服务器发送的一个 PUBLISH 包中包含的 Topic Alias 值为 1，服务器给客户端发送的 Topic Alias 值也为 1，那么很有可能它们引用的是不同的 Topic。。。

#### Response Topic
8(0x08)。
该属性由 UTF-8 字符串编码，用作响应消息的 Topic Name。Response Topic 不能包含通配符字符。该属性只能出现一次，Response Topic 的存在会把消息标识为请求。

服务器必须将未改变的 Response Topic 发送给所有正在接收应用消息的订阅者。

带有 Response Topic 的应用消息接收者通过使用 Response Topic 作为 PUBLISH 包的 Topic Name 来发送响应。如果 Request Message 包含了一个 Correlation Data，那么 Request Message 的接收者也应该包含这条 Correlation Data 作为 Response Message 中的 PUBLISH 包中的属性。

#### Correlation Data
9(0x09)
该属性由二进制数据块来表示。Correlation Data 被 Request Message 的发送者用来辨别当接收到响应消息的时候是响应哪一个请求。该属性只能出现一次，如果该属性不存在，请求者也不会需要任何 correlation data。

服务器必须将未改变的 Correlation Data 发送给所有正在接收应用消息的订阅者。Correlation Data 的值只对 Request Message 的发送者以及 Response Message 的接收者有意义。

同时包含 Response Topic 和 Correlation Data 的应用消息接收者通过使用 Response Topic 作为 PUBLISH包的 Topic Name 来发送响应。客户端也应该发送未改变的 Correlation Data 来作为响应中的 PUBLISH 包的一部分。

如果 Correlation Data 包含了某些信息，这些信息被客户端响应请求时修改了会引发应用程序失败的问题，那么开发者就需要将这些信息做加密或哈希处理，

#### User Property
38(0x26)
同之前 CONNECT 包中描述 User Property 的大致相同，需要注意的不同点是：

当转发应用消息给客户端的时候，服务器必须在 PUBLISH 包中发送所有未改变的 User Properties 给客户端。在转发应用消息的时候，服务器必须维护 User Properties 的顺序。

此属性旨在提供一种传输应用层 name-value tags 的方法，其意义和解释仅由负责发送和接收它们的应用程序知道。

#### Subscription Identifier
11(0x0B)
该属性由 Variable Byte Integer 来表示。

Subscription Identifier 的值可以在 1～268435455 中取。若其值为 0，则协议错误。若发布内容是多个订阅匹配的结果，则需要包含多条 Subscription Identifiers，这种情况下，它们(Subscription Identifier)的次序就不太重要了。

#### Content Type
3(0x03)
该属性由一个 UTF-8 编码的字符串来表示，用来描述应用消息的内容。该属性只能出现一次。其值由收发 PUBLISH 消息的应用程序来定义。

服务器必须将未改变的 Content Type 发送给所有正在接收应用消息的订阅者。

UTF-8 编码的字符串可以使用 MIME 内容类型字符串去描述应用消息的内容。但是，由于字符串的定义和解释都是由收发消息的应用程序负责的，所以 MQTT 除了会验证 Content Type 是否是有效的 UTF-8 编码字符串以外不会再做其他验证。

### Payload 与 Response
相比 v3.1.1，v5.0 中 PUBLISH 包的 payload 和 Response 未变，

### Actions
v5.0 中，由于属性的引入，Actions 这里多了很多需要注意的地方。

客户端使用 PUBLISH 包来发送应用消息给服务器，以分发给匹配订阅的客户端。

服务器使用 PUBLISH 包来发送应用消息给每个订阅匹配的客户端。如果 PUBLISH 包包含 Subscription Identifier 的话，它会被传到 SUBSCRIBE 包中。

当客户端用带有通配符的 Topic Filters 去订阅的时候，客户端的订阅可能会重叠，以便发布的消息与多个过滤器匹配。在这种情况下，服务器必须向客户端发送关于所有匹配订阅的最大QoS的消息。

此外，服务器可以传递消息的更多副本，每个额外的匹配订阅一个副本，并与每个订阅的 QoS 相关。
 
如果客户端收到QoS大于最大QoS的未经请求的应用消息（不是由订阅产生），它将使用 Reason Code 为0x9B（不支持 QoS）的DISCONNECT 包来断开连接。

如果客户端为任何一个重叠的订阅指定了一个 Subscription Identifier。那么服务器就必须在作为订阅结果发布的消息中发送这些 Subscription Identifiers。如果服务器发送的是消息的单个副本，那么它必须在 PUBLISH 包中包含所有具有 Subscription Identifiers 的匹配订阅的 Subscription Identifier。它们的次序并不重要，如果服务器发送了多个 PUBLISH 包，那么它就必须发送带有 Subscription Identifier 的匹配订阅的每个 Subscription Identifier。

客户端可能会订阅几份与发布相匹配的订阅，并且其中多份订阅使用的相同的 identifier。在这种情况下, PUBLISH 包会带有多个相同的 Subscription Identifiers。

若 PUBLISH 包包含的 Subscription Identifier 不是从 SUBSCRIBE 包中流动接收过来的，那么会导致出现协议错误。从客户端发送到服务器的 PUBLISH 包不能包含 Subscription Identifier。

如果 subscription 是共享的，那么只有来自正在接收消息的客户端中的 SUBSCRIBE 包所存在的 Subscription Identifier　是从 PUBLISH 包中返回的。

当接收者接收到 PUBLISH 包后，它的行为取决于 QoS 等级
如果 PUBLISH 包包含了一个 Topic Alias，那么接收者会按以下的方式来处理:
1). 若 Topic Alias 的值为 0 或者大于 Maximum Topic Alias，则协议错误，接收者会使用 0x94 Reason Code(Topic Alias 无效)来断开连接。 

2). 若接收者已经为 Topic Alias 建立了映射，那么:
    a) 若包的 Topic Name 的长度为 0，那么接收者就会按照与 Topic Alias 一致的 Topic Name 去处理它
    b) 如果包的 Topic Name 长度非零，接收者就会使用该 Topic Name 来处理包，并且准备为即将到来的包去更新 Topic Alias 和 Topic Name 的映射。
    
3). 如果接收者还没有拥有这个 Topic Alias 的映射，那么：
    a) 如果包中 Topic Name 的长度为 0，则协议错误，接收者会使用带有 0x82 的 Reason Code(协议错误) 的 DISCONNECT 包来断开连接。
    b) 如果数据包包含非零长度的 Topic Name，接收者会处理该 Topic Name 来处理该包，并且会给即将到来的包去设置 Topic Alias 到 Topic Name 的映射。

如果服务器像 mqtt v3.1.1 协议中那样，不支持属性或其它 mqttv5.0 支持的特性，那么以不同的协议等级去分发应用消息，一些在应用消息中的信息会丢失，依赖于这些信息的应用程序也不会正常工作。

当客户端没有从服务器那里收到带有 Reason Code 大于等于 128 的PUBACK 包，PUBCOMP 包，或 PUBREC 包的时候，客户端不能发送超过 Receive Maximum 的 QoS1 和 QoS2 的 PUBLISH 包。如果它在没有发送 PUBACK 或 PUBCOMP 响应的情况下接收了超过 Receive Maximium 的 QoS1 和 QoS2 的 PUBLISH 包，服务器会使用带有 Reason Code 0x93(Receive Maximum exceeded) 的 DISCONNECT 包去断开连接。

客户端不得因为在已经发送了 Receive Maximum PUBLISH 包但未接收到确认的情况下延迟发送 PUBLISH 以外的包。Receive Maximum 的值只会在当前网络连接下应用。

注：
1. 客户端可以在没有收到确认包的情况下选择发送少于 Receive Maximum　的消息给客户端，即使客户端要发送给服务器的消息数量大于 Receive maximum 值。
2. 客户端在中断 QoS1 和 QoS2 的 PUBLISH 包的时候也可以选择去中断发送 QoS0 的 PUBLISH 包。
3. 如果客户端在它收到 CONNACK 包之前发送了 QoS1 或 QoS2 的 PUBLISH 包，那么它就有被断开连接的风险，因为它发送的 PUBLISH 包超过了 Receive Maximum 的发布内容。

## PUBACK - Publish 确认

### Fixed header
与 v3.1.1 基本一样，不过由于 Reason Code 的引入，描述 variable header 的 length 的 Remaining Length field 不再限定为 2.

### Variable Header
相比 v3.1.1 的 Variable Header，　v5.0 的 Variable 多了 PUBACK Reason Code 和 Property Length。原本 2 个字节的 PUBACK 包变成了 4 个字节。
若 Remaining Length 为 2 ，那么就没有 Reason Code 会被使用除了值为 0x00 (Success)的会被用。

#### PUBACK Reason Code
0    0x00            Success                 ; 消息被接收，QoS1 消息的发布会继续。
128  0x10        No matching subscribers.    ; 消息被接收却没有接收者，该 Reason Code 只会被服务器发送。若服务器知晓没有订阅者匹配的话，它可以使用 Reason Code 代替 0x00(Success)
128  0x80          Unspecified error         ; 接收者没有接收到 publish 包，服务器无意揭示失败原因或者其它 Reason Code 无法解释该错误原因。
131  0x83  Implementation specific error     ; PUBLISH 包有效但是接收者却没有意愿接收它
135  0x87           Not authorized           ; PUBLISH 包没有被授权
144  0x90         Topic Name invalid         ; Topic Name 的格式没有问题但不被服务器或客户端接收
144  0x91      Packet identifier in use      ; Packet Identifier 已经被使用了，它表明客户端和服务器的会话状态不匹配
151  0x97          Quota exceeded            ; 已超出实现或管理上的限制
153  0x99      Payload format invalid        ; Payload format 没有匹配到指定的 Payload Format Indicator。

发送 PUBACK 包的客户端或服务器必须使用 PUBACK Reason Codes 的其中一个。若 Reason Code 是 0x00(Success)，那么 Reason Code 和 Property Length 都可以被忽略，并且不会有属性。在这种情况下，PUBACK 的 Remaining Length 长度为 2。

### PUBACK Properties
#### Property Length
与其他类型包的 Property Length 一样。

#### Reason String
31(0x1F)
基本结构和 Connect 包中的 Reason String 一致。需要额外注意的是：
发送者通过这个值给接收者给出额外的信息。如果 PUBACK 包的大小增大到超出接收者指定的 Maximum Packet Size，发送者就不能再发送属性了。该属性在单个包中只能出现一次。

#### User Property
38(0x26)
UTF-8编码字符串对，该属性可以被用来提供额外的诊断信息以及其他信息，如果 PUBACK 包的大小增大到超出接收者指定的 Maximum Packet Size，发送者就不能再发送该属性了。和前面提到的 User Property 一样，该属性可以出现多次，且同样的名字也可以出现多次。

## PUBREC - PUBLISH 包接收(QoS 2 传输, Part 1)
和 PUBACK 包比较相似，Variable Header 都比 v3.1.1 多了 2 个字节。多出来的都分别是 Reason Code 和 Property Length。

### PUBREC Reason Code
0    0x00             Success                ; 消息被接收，QoS2 消息的发布会继续。
16   0x10     No matching subscribers        ; 消息被接收却没有接收者，该 Reason Code 只会被服务器发送。若服务器知晓没有订阅者匹配的话，它可以使用 Reason Code 代替 0x00(Success)
128  0x80          Unspecified error         ; 消息被接收却没有接收者，该 Reason Code 只会被服务器发送。若服务器知晓没有订阅者匹配的话，它可以使用 Reason Code 代替 0x00(Success)
131  0x83  Implementation specific error     ; PUBLISH 包有效但是接收者却没有意愿去接收它
135  0x87           Not authorized           ; PUBLISH 包没有被授权
144  0x90         Topic Name invalid         ; Topic Name 的格式没有问题但不被服务器或客户端接收
145  0x91       Packet Identifier in use     ; Packet Identifier 已经被使用了，它表明客户端和服务器的会话状态不匹配
151  0x97          Quota exceeded            ; 已超出实现或管理上的限制
153  0x99      Payload format invalid        ; Payload format 没有匹配到指定的 Payload Format Indicator。

### PUBREC Properties
属性这里和 PUBACK 一样。

## PUBREL－PUBLISH release (QoS2 传输，Part 2)

和 PUBACK 和 PUBREC 包相似度很高，相比 5.0 ，Variable Header 多了两个字节，用于描述 Reason Code 和 Property Length。

Fixed Header 比较特殊，预留的四位分别是　0, 0, 1, 0,　不是 0 ,0 , 0, 0

Property 同上。

### PUBREL Reason Code
146  0x92    Packet Identifier not found  ; Packet identifier 是未知的。在恢复期间这不是错误，但在其他时间段表示客户端和服务器之间会话状态不匹配。

## PUBCOMP - PUBLISH complete (QoS 2 传输，part 3)error
结构同上，Property 同上，Reason Code 有所区别。

### Reason Code
0    0x00             Success             ; 消息被接收，QoS2 消息的发布会继续。
146  0x92    Packet Identifier not found  ; Packet identifier 是未知的。在恢复期间这不是错误，但在其他时间段表示客户端和服务器之间会话状态不匹配。

## SUBSCRIBE-订阅请求
Fixed Header 比较特殊，预留的四位分别是　0, 0, 1, 0,　不是 0 ,0 , 0, 0
### SUBSCRIBE Variable Header
在 v5.0 中的 SUBSCRIBE 包的 Variable Header 比 v3.1.1 多了 Properties 。

#### SUBSCRIBE Properties
##### Property Length
属性长度

##### Subscription Identifier
11(0x0B)
与 PUBLISH 包中的 Subscription Identifier 基本一样，需要多注意的地方是：Subscription Identifier 是与 SUBSCRIBE 包中任何创建或修改的 subscription 结果相关联起来。如果这里有一个 Subscription Identifier，那么它就会和 subscription 一直被存储，如果没有该属性，那么这种缺失的情况也会和 subscription 存储在一起。

##### User Property
38(0x26)
基本同之前提到的 User Property 一样。需要额外注意的是：在 SUBSCRIBE 包中的 User Properties 可以被用来从客户端到服务器发送 subscription 相关的 properties。

### SUBSCRIBE Payload
v5.0 的 SUBSCRIBE 的 Payload 和之前的不太一样。这里每个 Topic Filter 后面跟了一个 Subscription Options。Payload 中必须包含至少一个 Topic Filter 和 Subscription Options 对。一个 SUBSCRIBE 包如果没有 Payload 的话，会导致协议错误。

#### Subscription Options
Subscription Options 的第 0 位和第 1 位表示的时 Maximum QoS 字段。该字段给出了服务器可以发送给客户端应用消息的最大 QoS 等级。如果 Maximum QoS 字段的值为 3 的话就表示协议错误。

Subscription Options 第二位表示无本地选项。如果值为 1，应用消息就不能转发给一个 ClientID 等于 publishing 连接的 ClientID 的连接。若在 Shared Subscription 中将 No Local 位设为1，则协议错误。

Subscription Options 的第三位表示保留为已发布选项。若该值为 1，被转发的应用消息在使用该 subscription 的时候会保留它们在被发布时的 RETAIN flag。若该值为 0，被转发的应用消息在使用该 subscription 的时候会有一个 RETAIN flag 被设为 0。当带有的 RETAIN flag 的值被设为 1　的订阅被建立的时候，Retained messages 会被发布。

Subscription Options 的第四第五位代表了 Retain Handling 选项。该选项用来表示当订阅建立的时候，是否 retained message 被发送了。在订阅建立之后的任何时刻，它都不会影响到 retained message 的发送。若没有 retained message 匹配到 Topic Filter，那么以下的所有地值的动作都是相同的。这些值是:
0 = 在订阅的时刻发送 retained messages
1 = 在订阅的时候发送 retained messages 除非订阅当前不存在
2 = 在订阅的时刻不发送 retained message
若发送的 Retain Handling value 为 3 的话，则协议错误。

Subscription Options 的第 6 第 7 位是预留给未来使用的。如果 Payload 中的任何一个预留位非零的话，那么服务器就会将该包视为格式错误的包。

注：
1. 在客户端发送消息给其它服务器的情况下，NO Local 和 Retain As Published 选项可以被用来实现桥接。
2. 当重连已经完成的时候，不发送 retained message 给一个已存在的 subscription 是非常有用的。客户端并不能确定订阅是否在上一个连接会话里被完成了。
3. 如果客户端希望接收更改通知并且不需要知道初始状态，则不发送由于新订阅而存储的保留消息很有用。
4. 如果服务器表示它不支持 retained messages，所有 Retain As Published 和 Retaine Handling 的有效值都会给出相同的结果，那就是在订阅的时候不会发送任何 retained message，并且它会在所有消息中将 RETAIN flag 设为 0。

#### SUBSCRIBE Actions
当服务器从客户端那里收到 SUBSCRIBE 包，服务器必须响应一个 SUBACK 包。SUBACK 包必须与它确认 SUBSCRIBE 包有相同的 Packet Identifier。

在服务器发送 SUBACK 包之前服务器就可以开始发送与订阅相匹配的 PUBLISH 包了。

如果服务器接收到一个 SUBSCRIBE 包，这个包中的 Topic Filter 与当前会话下的一个非共享订阅的 Topic Filter 相同，那么它就必须以这个新的订阅去替代旧的已存在的 Subscription。在这个新的订阅中的 Topic Filter 将会和之前的那个订阅的 Topic Filter 相同，但是它们的订阅选项可能不同。如果 Retain Handling 选项为 0，任何已存在匹配到 Topic Filter 的 retained messages 都必须被重发，但是应用消息不能因为订阅被替换而丢失。

如果服务器接收到一个 SUBSCRIBE 包，这个包中的 Topic Filter 与当前会话下的一个非共享订阅的 Topic Filter 不相同，那么就要创建一个新的非共享订阅。如果 Retain Handling 选项不是 2，那么所有匹配的 retained message 都要被发送给客户端。

由服务器发送给客户端的 SUBACK 包必须在每一个 Topic Filter/Subscription 选项对中包含一个 Reason Code。Reason Code 应该显示订阅准许的最大 QoS 等级或者表示订阅失败。服务器可能授予比订阅者请求的QoS 更低的最大 QoS 。响应订阅而发送的应用消息的 QoS 必须是最初发布的消息的 QoS 的最小值以及服务器授予的最大 QoS。在原始消息发布为 QoS 1且授予的最大 QoS 为 QoS 0的情况下，服务器被允许发送消息的副本给订户。

注：
1. 如果订阅客户端已被授予特定 Topic Filter 的最大 QoS 1，则匹配 Topic Filter 的 QoS 0 的应用消息将以 QoS 0 去传递给客户端。这意味着客户至多收到一条消息副本。另一方面，发布到相同主题的QoS 2消息由服务器降级到QoS 1以传送到客户端，以致于客户端可能会收到消息的重复副本。
2. 如果订阅客户端已被授予最大 QoS 0，则最初作为 QoS 2 发布的应用程序消息可能在到客户端的跳跃中丢失，但服务器不应该发送该消息的副本。发布到相同主题的 QoS 1 消息可能在传输到该客户端时丢失或重复。
3. 在 QoS 2 上订阅 Topic Filter 相当于说“我想要接收消息以消息发布时的 QoS 匹配到这个 filter ”。这意味着发布者负责确定消息可以传递到的最大QoS，但订阅者能够要求服务器将 QoS 降级到更适合其使用的一个。 

Subscription Identifiers 是服务器会话状态的一部分，并且会返回给正在接收匹配 PUBLISH 包的客户端。当服务器接收到 UNSUBSCRIBE 包的时候，或者当服务器从客户端接收到的 SUBSCRIBE 包有相同的 Topic Filter，但是 Subscription Identifiers 不同或者没有 Subscription Identifiers，或者当服务器在 CONNACK 包中发送的会话呈现为 0，那么它们会被从服务器会话状态中移除。

Subscription Identifiers 不构成客户端中客户端会话状态的一部分。在一个有用的实现中，客户端将 Subscription Identifier 与其他客户端端状态相关联，当客户端取消订阅时，客户端订阅具有不同 Identifier 或无 Identifier 的相同 Topic Filter 时，或客户端收到订阅时会话在 CONNACK 数据包中呈现 0 时。它们会从服务器会话状态中移除。

服务器不需要在重新传输的 PUBLISH 数据包中使用相同的 Subscription Identifiers 集。客户端可以通过发送包含主题过滤器的 SUBSCRIBE 数据包来重新生成订阅，该主题过滤器与当前会话中现有订阅的主题过滤器相同。如果客户端在初始传输 PUBLISH 包之后重新订阅并且使用了不同的 Subscription Identifier，则允许服务器在任何重传中使用来自第一次传输的标识符。或者允许服务器在重传期间使用新的 identifiers。在发送包含新 identifier的 PUBLISH 包之后，不允许服务器恢复旧的 identifier。

使用场景，用于说明 Subscription Identifiers。
* 客户端实现通过其编程接口指示发布匹配多个订阅。每次新的订阅生成的时候，客户端实现都会生成一个新的 identifier。如果返回的发布包含多个订阅标识符，则该发布匹配多个订阅。
* 客户端实现允许订阅者将消息订阅到与订阅相关联的回调。客户端实现生成一个 identifier，该 identifier 将 identifier 唯一地映射到回调。当收到发布时，它使用 subscription identifier 来确定使用驱动哪个回调。
* 客户端实现返回用于在传递已发布消息时对应用程序进行订阅的主题字符串。为实现此目的，客户端生成一个 identifier，来唯一地标识Topic Filter。当发布被接收到时，客户端实现会使用 identifiers 去查找最初的 Topic Filters 并且把它们返回到 Client 应用程序。
* 网关将从服务器接收的发布转发给已订阅网关的客户端。网关的实现是维护它接收到的每个唯一 Topic Filter 到它还接收的 ClientID 的映射。它会为每一个转发到服务器的 Topic Filter 生成一个唯一的 identifier。当发布被接收到时，网关使用它从服务器接收到的 Subscription Identifiers 来查找 Client Identifier 以及与它们相关联 Subscription identifier 对。网关把这些添加到它发送给客户端的 PUBLISH 包。如果上游服务器因为消息匹配了多个 subscriptions 而发送了多个 PUBLISH 包，则该行为会被镜像到服务器。



## SUBACK - 确认订阅
Fixed Header 同 SUBSCRIBE 包一样。

### SUBACK Properties
#### Properties Length
属性长度
#### Reason String
31(0x1F),
UTF-8 编码，为提供人类可读的诊断信息而设计，不应由客户端来解析，若 SUBACK 包大小超过客户端指定的 Maximum Packet Size，服务器就不能发送该属性了，该属性只能出现一次。

#### User Property
38(0x26)
基本和之前描述的 User Property 一样，若 SUBACK 包大小超过客户端指定的 Maximum Packet Size，服务器就不能发送该属性了，该属性只能出现一次。

### SUBACK Payload
SUBACK Payload 包含一个 Reason Codes 列表。每一个 Reason Code 要与被确认的 SUBSCRIBE 包的 Topic Filter 相一致。在 SUBACK 包中 Reason Codes 的次序要与 SUBSCRIBE 包中 Topic Filter 的次序相匹配。

0    0x00            Granted QoS 0                 ; 订阅被接收，最大被发送的 QoS 为 QoS 0，可能会比被请求的 QoS 更低。
1    0x01            Granted QoS 1                 ; 订阅被接收，最大被发送的 QoS 为 QoS 1，可能会比被请求的 QoS 更低。
2    0x02            Granted QoS 2                 ; 订阅被接收，最大被发送的 QoS 为 QoS 2。
128  0x80            Unspecified error             ; 订阅未被接收且服务器不愿揭示任何原因，或者没有任何 Reason Code 可解释该错误。
131  0x83      Implementation specific error       ; SUBSCRIBE 包有效，但是服务器没有接收它。
135  0x87           Not authorized                 ; 客户端没有被授权去创建订阅。
143  0x8F         Topic Filter invalid             ; Topic Filter 格式正确，但是没有被客户端认可。
145  0x91       Packet Identifier in use           ; 指定的 Packet Identifier 已经在被使用了。
151  0x97          Quota exceeded                  ; 已超出实现或管理上的限制
158  0x9E      Shared Subscriptions not supported  ; 服务器还未为该客户端提供共享订阅支持。
161  0xA1  Subscription Identifiers not supported  ; 服务器还未支持共享订阅，订阅未被接受。
162  0xA2   Wildcard Subscriptions not supported   ; 服务器还未支持通配符订阅，订阅未被接受。

对应的 SUBSCRIBE 数据包中的每个 Topic Filter 始终有一个 Reason Code。如果 Reason Code 不是特定于 Topic Filter（例如0x91（正在使用的 Packet Identifier）），则为每个 Topic Filter 设置 Reason Code。

## UNSUBSCRIBE - 取消订阅请求
UNSUBSCRIBE 包是由客户端发送给服务端用来取消订阅的控制包。

Fixed Header 比较特殊，预留的四位分别是　0, 0, 1, 0,　不是 0, 0, 0, 0  。

Remaining Length 字段表示的是 Payload 和 Variable Header 加起来的长度。

### Variable Header
UNSUBSCRIBE Variable 依次包含了以下字段：Packet Identifier 和 Properties。

UNSUBSCRIBE 包的 Properties 的仅仅只有 Property Length 和　User Property，其作用基本与之前提到 Property Length 和 User Property 一样。

### UNSUBSCRIBE payload

UNSUBSCRIBE 包包含了一个客户端希望去取消订阅的 Topic Filters 列表。在 UNSUBSCRIBE 包中的 Topic Filters 必须是一个 UTF-8 编码的字符串。UNSUBSCRIBE 包的 Payload 至少要有一个 Topic Filter，否则协议错误。

### UNSUBSCRIBE Actions
Action 部分基本与 v3.1.1 版本的内容相同，与之不同的由于 v5.0 引入了共享订阅，所以，这里要额外注意的是:

如果 Topic Filter 表示的是一个共享订阅，那么该会话会与共享订阅分离开来。如果会话是共享订阅相关联的唯一会话。那么共享订阅就会被删掉。



## UNSUBACK - 取消订阅确认
Fixed Header 和 Variable Header 基本同 SUBACK 的 Fixed Header 和 Variable Header 一样。主要区别在于 Payload 中返回的 Reason Code。


服务器在发送 UNSUBACK 包的时候必须使用以下 Reason Code 中的一个去应答接收到的每一个 Topic Filter
0    0x00             Success             ; 删除订阅
17   0x11      No subscription existed    ; 没有匹配到客户端使用的 Topic Filter
128  0x80          Unspecified error      ; 取消订阅没有成功，且服务器也无意提示原因，或者说没有任何一种 reason code 适用于这种情况
131  0x83  Implementation specific error  ; UNSUBSCRIBE 包有效但是服务器没有接收它。
135  0x87           Not authorized        ; 客户端没有授权来取消订阅
143  0x8F         Topic Filter invalid    ; Topic Filter 是正确的格式但是没有被客户端准许
145  0x91       Packet Identifier in use  ; 指定的 Packet Identifier 已经被使用了

## PINGREQ - PING 请求
同 v3.1.1 的 PINGREQ 包

## PINGRESP - PING 响应
同 v3.1.1 的 PINGREQ 包

## DISCONNECT -　断连通知
相比 v3.1.1 的 mqtt协议，v5.0 的协议中该包多了 Variable Header 用于存放各种属性。

客户端和服务器都要验证 DISCONNECT 包的 Fixed Header 中的 reserved 位全都被设为 0.如果它们非 0，那么它将会发送一个带有 Reason code 0x81(包格式错误)的 DISCONNECT 包。

DISCONNECT 包的 Variable Header 中依次包含了 Reason Code 和 Properties 两个字段。

DISCONNECT 没有 Payload
### Reason Code
0    0x00       Normal disconnection              ; 客户端或服务器 ; 正常关闭连接，不发送 Will Message 
4    0x04    Disconnect with Will Message         ; 客户端         ; 客户端希望断开连接，但是需要服务器发布它的 Will Message
128  0x80          Unspecified error              ; 客户端或服务器 ; 连接关闭但是发送者不愿意或没法揭露原因 
129  0x81          Malformed Packet               ; 客户端或服务器 ; 接收到的包于协议标准定义的不一致 
130  0x82           Protocol Error                ; 客户端或服务器 ; 收到了未预期的或乱序的包 
131  0x83  Implementation specific error          ; 客户端或服务器 ; 收到的包有效但无法被该实现处理
135  0x87           Not authorized                ; 服务器         ; 请求未得到授权 
137  0x89            Server busy                  ; 服务器         ; 服务器繁忙且不能继续处理客户端发来的请求 
139  0x8B       Server shutting down              ; 服务器         ; 服务器正在关机 
141  0x8D         Keep Alive timeout              ; 服务器         ; 连接被关闭了因为已经有 1.5 倍的 Keepalive 的时间段中没有收到包了
142  0x8E         Session taken over              ; 服务器         ; 另外一个使用相同 ClientID 的连接已经被建立导致这个连接被关闭。
143  0x8F         Topic Filter invalid            ; 服务器         ; Topic Filter 格式正确，但是没有被服务器接收
144  0x90         Topic Name invalid              ; 客户端或服务器 ; Topic Name 格式正确，但是没有被客户端或服务器接收 
147  0x93    Receive Maximum exceeded             ; 客户端或服务器 ; 客户端或服务器已收到超过其尚未发送 PUBACK 或 PUBCOMP 的“Receive Maximum”发布。
148  0x94    Topic Alias invalid                  ; 客户端或服务器 ; 客户端和服务器已经接收到一个包含的 Topic Alias 大于它在 CONNECT 包 CONNACK 包中的 Maximum Topic Alias 的 PUBLISH 包。
149  0x95           Packet too large              ; 客户端或服务器 ; 包的大小大于此客户端或服务器的最大数据包大小
150  0x96      Message rate too high              ; 客户端或服务器 ; 接收数据的速率太高了
151  0x97          Quota exceeded                 ; 客户端或服务器 ; 超出实现或管理的限制
152  0x98       Administrative action             ; 客户端或服务器 ; 由于管理员操作而关闭连接
153  0x99      Payload format invalid             ; 客户端或服务器 ; Payload format 不会匹配到 Payload Format Indicator 指定的那一个
154  0x9A      Retain not supported               ; 服务器         ; 服务器不支持 retained messagess
155  0x9B       QoS not supported                 ; 服务器         ; 客户端指定的 QoS 大于 CONNACK 中 Maximum QoS 指定的 QoS
156  0x9C      Use another server                 ; 服务器         ; 客户端应该暂时更改服务器
157  0x9D     Server moved                        ; 服务器         ; 服务器被移除了，客户端需要永久地更改口
158  0x9E      Shared Subscriptions not supported ; 服务器         ; 服务器不支持共享订阅
159  0x9F     Connection rate exceeded            ; 服务器         ; 连接被关闭，因为连接速率太高
160  0xA0     Maximum connect time                ; 服务器         ; 最大授权的连接时间被超出
161  0xA1  Subscription Identifiers not supported ; 服务器         ; 服务器不支持 Subscription Identifier; subscription 不被接收
162  0xA2   Wildcard Subscriptions not supported  ; 服务器         ; 服务器不支持通配符订阅，订阅不被接收

客户端或服务器发送的 DISCONNECT 包必须使用 DISCONNECT Reason Code 的值。如果 Reason Code 为 0x00 (正常断连)且该控制包没有属性，那么 Reason Code 和 Property Length 都会被删除。在这种情况下 DISCONNECT 包的 Remaining Length 值为 0。

DISCONNECT 包是用来指明在没有确认数据包（例如 QoS 0 发布）或客户端或服务器无法继续处理连接的情况下断开连接的原因。

该信息可以被客户端用来决定是否重新尝试连接以及在重新尝试连接之前应该等待多长时间。

### DISCONNECT 属性
#### Property Length
该发生由一个可变字节整形来编码，如果 Remaining Length 小于 2，那么它就会使用 0 来代替它。

#### Session Expiry Interval
17(0x11)
与 CONNECT 包中的 Session Expiry Interval 相似，额外需要注意的是:

如果 CONNECT 包中的 Session Expiry Interval 值为 0，那么在客户端发送的 DISCONNECT 包中设置一个非 0 的 Session Expiry Interval 值会导致协议错误，如果服务器收到的 Session Expiry Interval 是一个非 0 的值，它就不会将其视为一个有效的 DISCONNECT 包。服务器使用 Reason Code 0x82 来断开连接。

#### Reason String
31(0x1F)
与 CONNECT 包中的 Reason String 一样。

#### User Property
38(0x26)
同上

#### Server Reference
28(0x1C)
该属性是一个 UTF -8 编码的字符串，客户端会将其用来标识另外一个在使用的服务器。该属性只能出现一次。
服务器发送的 DISCONNECT 包会包含一个 Server Reference 和 Reason Code 0x9C(使用另一台服务器)或 0x9D(服务器被移除)

### DISCONNECT Actions
发送者在发送完 DISCONNECT 包之后，必须：
* 不能在那个网络连接中再发送 MQTT 控制包了
* 关闭网络连接

在接收到一个带有 Reason Code 0x00(Success)的 DISCONNECT 包之后，服务器必须：
* 不打印任何与当前连接相关联的 Will Message 然后丢弃它。

在收到 DISCONNECT 包之后，接收者必须：
* 关闭网络连接。

## AUTH － 认证交换
这是 MQTT 5.0 中新增的控制数据包，非常重要!

AUTH 包会在服务器和客户端之间互相传递，它会作为扩展认证交换的一部分来交换，比如说询问/响应认证(challenge/response authentication)，如果CONNECT数据包不包含相同的认证方法（Authentication Method），则服务器或客户端发送的 AUTH 包会导致协议错误。

AUTH 包没有 Payload
### AUTH Fixed Header 
Fixed Header 的 0~3 位都是预留位，都需要置为 0。

### AUTH Variable Header
Variable Header 的 AUTH 包依次包含了以下几个字段：Authenticate Reason Code 和 Properties

#### Authentication Reason Code
Variable Header 里面的 Byte 0 （即第一个字节）是 Authenticate Reason Code。单字节无符号 Authentication Reason Code 字段如下：

0    0x00          Success               ; 客户端　　　　 ; 认证成功
24   0x18    Continue authentication     ; 客户端或服务器 ; 继续使用另一步去身份认证
25   0x19         Re-authenticate        ; 客户端　　　　 ; 开始重新认证

#### AUTH Properties
Reason String 和 User Property 与其它属性没有什么区别

##### Property Length
基本和其他包的 Property Length 一样

##### Authentication Method
21(0x15)
一个 UTF-8 编码的字符串，包含了 authentication method 的名字。无论是漏掉了该属性还是重复该属性都会导致协议错误。

##### Authentication Data
22(0x16)
一个包含 authentication data 的二进制数据。该属性只能在该控制包中出现一次，数据内容由 authentication method 定义。

# Operational behavior
## Session State
MQTT 5.0 在 Session State 上的行为有所变化:
为了实现 QoS1 和 QoS2 的协议流，客户端和服务器需要将状态与 Client Identifier 关联起来，这称为会话状态。服务器也可以将订阅存储为会话状态的一部分。

会话可以在一系列的网络连接中继续，它持续的时间长度为最新的网络连接加上 Session Expiry Interval 的时间。

客户端中的会话状态包括:
* 发送给服务器的 QoS1 和 QoS2 消息，但是没有被完全确认
* 从服务器那里接收到 QoS2 消息，但是没有被完全确认

服务器上的会话状态包括:
* 即使会话状态的其余部分为空也存在的会话状态
* 包含任意 Subscription Identifier 的客户端订阅
* 被发送给客户端的 QoS1 和 QoS2 消息，但未被完全确认
* 等待传输到客户端的 QoS1 和 QoS2 消息以及**可选**的等等传输到客户端的 QoS0 的消息。
* 从客户端那里收到的 QoS2 消息，但是没有被完全确认，还有 Will Message 和 Will Delay Interval
* 当前会话还没有被连接的情况下会话结束的时间以及会话状态被丢弃的时间

保留的消息不会被构成服务器会话状态的一部分，它们也不会因为会话结束而被删除。

### Storing Session State
在网络连接打开的情况下，客户端和服务器不能丢弃会话状态。当网络连接关闭且 Session Expiry Interval 过期时，服务器必须丢弃会话状态。

其它行为描述和 mqtt v3.1.1 中的描述一样。

## Network Connections (网络连接)
与 mqttv3.1.1 中的描述一样。

## Quality of Service levels and protocol flows(QoS 等级和协议流)
与 MQTT v3.1.1 协议相比，QoS 消息的发送行为没有太大的变化，唯一的变化在 QoS2 传输协议里收发消息者的行为：

在 QoS 2 传输协议中，发送者：
* 当发送一个新的应用消息的时候，必须分配一个未使用过的 Packet Identifier。
* 发送的 PUBLISH 包的的 QoS = 2 , DUP =　0。
* 直到从接受者那里接收一个相应的 PUBREC 包为止，发送者都必须把 PUBLISH 包视为 unacknowledged  对待。
* 当收到带有 Reason Code 小于 0x80 的 PUBREC 包的时候必须发送一个 PUBREL 包，Packet Identifier 必须和 PUBREC 包的一样。
* 直到从接受者那里接收一个相应的 PUBCOMP 包为止，发送者都必须把 PUBLISH 包视为 unacknowledged  对待。
* 一旦发送了 PUBREL 包就不要再发送 PUBLISH 包了。
* 如果 PUBLISH 包被发出了，就不能再应用消息到期的设定了。

一旦服务器接收到了 PUBCOMP 包或者 Reason Code 大于等于 0x80 的 PUBREC 包，Packet Identifier 就可以重用了。

注意：当发送者在等待接收确认包的时候，允许发送者根据根据流程控制来发送带有不同 Packet Identifiers 的更多 PUBLISH 包。

在 QoS 2 传输协议中，接收者:
* 必须用传入 PUBLISH 包的 Packet Identifier 去响应 PUBREC 包，这个 PUBACK 包已接受应用消息的所有权。
* 如果它已经发送了一个带有大于等于 0x80 的 Reason Code 的 PUBREC 包，接收者必须将随后发来的任何包含该 Packet Identifier 的 PUBLISH 包视为一个新的应用消息。
* 在收到 PUBREL 包前，接收者必须通过改善一个 PUBREC 请求来确认任何后续的具有相同 Packet Identifier 的 PUBLISH 分组，在这种情况下，它绝不能让重复的消息发送给之前的接收者。
* 必须通过发送一个带有相同 Packet Identifier 的 PUBCOMP 包来响应 PUBREL 包。
* 在发送 PUBCOMP 之后，接收者必须把随后发来的带有相同 Packet Identifier 的 PUBLISH 包视为新的 PUBLISH。
* 即使它已经应用应用了消息到期，它也必须继续 QoS2 确认序列。

## Message delivery retry
当客户端将 Clean Start 设为 0 进行重连并且已经有一个会话存在时，客户端和服务器都必须重传任何一个未确认的 PUBLISH 包（QoS > 0 的情况）并且 PUBREL 包使用最初 Packet Identifier。这是客户端和服务器需要进行重传的唯一场景。客户端和服务器不能在其他时候重发消息。

如果收到的 PUBACK 或 PUBREC 包包含了一个大于等于 0x80 的 Reason Code ，那么相关的 PUBLISH 包会被视为已确认，并且不能再重传了。

在发送完 PUBREC 包或 PUBCOMP 包之前，接收者不需要完成应用消息的传输。当其原始发送方接收到 PUBREC 包时，应用消息的所有权将会被转移到接收者。但是，接收者在接收到所有权之前都需要执行所有可能会导致转发失败（比如限额超出，认证失败等等这些错误）的检查。接收者使用 PUBREC 包中的相应的 Reason Code 来表明成功或失败。

## Message ordering 
在 mqtt v5.0 中，客户端在实现协议流的时候需要遵循的规则不变

v5.0 的协议标准里添加了对 Ordered Topic 的定义:
所谓的 Ordered Topic 即是客户端可以确定来自同一客户端并且收到相同 QoS 的主题中的应用消息的顺序就是它们被发布的顺序。

还有一点需要注意：由于 mqtt v5.0 引入了共享订阅，所以这里服务器默认情况下都要在当它在非共享订阅下转发消息的时候将每一个 Topic 视为有序 Topic。

## Topic Names and Topic Filters
Topic Names 和 Topic Filters 这里什么变化

## Shared Subscription
一个共享订阅可以和多个正在订阅的 MQTT 会话关联起来。比如一个非共享订阅，它有一个 Topic Filter 和订阅选项; 但是与其 Topic Filter 相匹配的发布只会被发到其订阅的会话之一。当多个消费客户端并行共享发布内容的处理的情况下，共享订阅是非常有用的。

共享订阅通过一个特别的 Topic Filter 范式来标识。Filter 的格式大概是以下这样:

`$/share/{ShareName}/{filter}`

* `$share`是一个字符串用来标记 Topic Filter 为一个共享订阅的 Topic Filter
* `{ShareName}`字符串里面不能包含"/", "+" 或"#"
* {filter}字符串的语法语义都和非共享订阅中的 Topic Filter 相同，可以像 非共享订阅中的 Topic Filter 那样用

共享订阅的 Topic Filter 必须以`$share` 的字符开始并且必须包含一个至少一个字符长度的 ShareName。ShareName 不能包含字符"/","+"或"#"，但是后面必须跟上"/"字符。"/"字符后面必须跟上 Topic Filter。

共享订阅是在 MQTT 服务器的 scope (不会翻，无论是作用域还是领域感觉都不太对)内而非会话中定义的。ShareName 是被包含在共享订阅的 Topic Filter 中，以便在具有相同 {filter} 组件的服务器上可以有多个共享订阅。

通常，应用程序使用 ShareName 来表示共享订阅的订阅会话组。

共享订阅是通过在 SUBSCRIBE 请求中使用一个共享订阅的 Topic Filter 来创建的。若只有一个会话订阅了某个共享订阅，那么该共享订阅的行为就会像非共享订阅那样，除非以下两种情况：
* 在与发布匹配的时候，`$share` 和 `{ShareName}` 部分都没有被考虑在里面。
* 当首次订阅时，Retained Message 不会被发送到会话中，当它们发布的其它消息被匹配到时，Retained Message 才会被发送。

若共享订阅存在，那么其它会话可以使用相同的共享订阅 Topic Filter 来订阅。新的会话会作为一个额外的订阅者与共享订阅关联起来。保留的消息不会被发送到新的订阅者。每一个与共享订阅相匹配的应用消息都会被发送到订阅到共享订阅的一个会话。

会话可以通过发送一个包含完整共享订阅的 Topic Filter的 UNSUBSCRIBE 包来主动地将其自身与共享订阅分离开来。当会话终结时，也会与共享订阅分离开。

只要与共享订阅关联的会话（已经向 Topic Filter 上发出了一个成功的 SUBSCRIBE 请求且尚未完成相应 UNSUBSCRIBE 操作的会话）还在，共享订阅就还能存在。即使最初创建共享订阅的会话已经取消订阅了，共享订阅还能继续存在，除非已经没有任何会话订阅该共享主题了。在已经没有任何会话在订阅该共享主题时，共享订阅就会结束，任何与其相关的未传输的消息也会被删除。

关于共享订阅的注意点:
* 如果有多个会话订阅了共享订阅，则服务器实现可以逐个消息地去选择使用哪个会话以及做出这样选择的标准
* 允许不同的订阅客户端在它们的 SUBSCRIBE 包中要求不同的 QoS 等级的请求。服务器来决定向客户端授予哪个最大的 QoS，并允许向不同的订阅者授予不同的最大的 QoS 级别。当发送应用消息到客户端时，服务器必须遵守客户端订阅的授权 QoS，与向发送消息到订阅者时一样。
* 如果服务器正在向其选定的订阅客户端发送 QoS2 消息，并且连接在消息传输之前就中断了，那么服务器必须要在客户端重新连接的时候完成消息传输。如果客户端会话在客户端重连之前就终结了，那么服务器不能将该应用消息发给其他订阅客户端。
* 如果服务器正在向其选定的订阅客户端发送 QoS1 消息，并且连接在服务器从客户端那里接收到确认包之前就断了，那么服务器可以等待客户端重连并且重新发送消息给客户端。如果客户端会话在客户端重连之前就终结了，那么服务器就应该发送应用消息到另一个订阅到相同共享订阅的客户端。在它丢失了与第一个客户端连接时就可以尝试发送消息给另外一个客户端。
* 如果客户端向服务器发来的 PUBLISH 包响应了一个包含的 Reason Code 大于等于 0x80 的 PUBACK 或 PUBREC 包，那么服务器就必须丢弃应用消息并且不再尝试将它发送给其它订阅者。
* 允许客户端去提交第二个 SUBSCRIBE 请求给一个已经订阅到该共享订阅的会话上的共享订阅。比如，它可能会这样做去更改其订阅的请求 QoS，或者因为它不确定在前一个连接关闭之前前一个订阅是否完成。这个操作不会增加会话与共享订阅关联的次数，因此会话将在其第一个 UNSUBSCRIBE 包上保留共享订阅。
* 每一个共享订阅都是互相独立的。因此很有可能两存在的共享订阅它们的 filter 是重叠的。在这样的情况下，匹配到这两个共享订阅的消息将会分别由这两个共享来处理。如果客户端有一个共享订阅和一个非共享订阅，并且消息与它们都匹配，则客户端还会因为它的共享订阅接收到一个消息的副本。消息的第二份副本会被传递到该共享订阅的订阅者中的其中一位，所以这可能会导致这个副本会被传送到该客户端。

## Flow Control
客户端和服务器通过一个 Receive Maximum 值来控制未确认的 PUBLISH 包的数量。Receive Maximum 确定了一个发送限额。这个限额是用来限制 QoS > 0 的，可以不接收 PUBACK(for QoS1) 或 PUBCOMP(for QoS2) 就发送的 PUBLISH 包的数量，而 PUBACK 和 PUBCOMP 包会以以下的方式去补充这个限额。

客户端或服务器在设置它的初始发送限额的值大于 0，但是不能超出 Receive Maximum。

每次客户端或服务器发送 QoS > 0 的 PUBLISH 包的时，它都会减少发送限额。如果发送限额为 0 时，e 客户端或服务器就不能再发送任何 QoS > 0 的 PUBLISH 包了。它可以选择继续发送 QoS0 的 PUBLISH 包，也可以选择中止发送这些包。即使在限额为 0 的情况下，客户端和服务器都必须继续处理和响应所有其它的 MQTT 控制包。

发送限额是按以下方式逐一增加的：

* 每次 PUBACK 包或 PUBCOMP 被接收到，不管 PUBACK 包或 PUBCOMP 包是否带有 error code。
* 每次接收到一个带有 Return Code 大于等于 0x80 的 PUBREC 包。

当发送限额等于初始发送限额时，它就会停止增加。在一个新的网络连接建立后，PUBREL 包的重传可能会导致它去尝试在发送限额达到初始发送限额的时候还去增加这个值。

发送限额和 Receive Maximum 的值不会在跨网络连接的情况下维持。每个新的网络连接重新建立的时候，这个两个值都会重新初始化。

## Request/Response
一些应用程序或标准可能希望在 MQTT 协议之上去跑一个 Request/Response 的交互。这个版本的 MQTT 协议通过包含以下几个属性来完成这个目标。

* Response Topic 
* Correlation Data
* Request Response Information
* Response Information

下面介绍一下怎么用上面几个属性。

客户端通过发布一个有 Response Topic 的应用消息来发送一个请求消息，请求可以包含一个 Correlation Data 属性。

### Basic Request Response
Request/Response 交互按照以下方式来走:
1. MQTT 客户端(请求者)会发布一条 Request 消息到一个 Topic 上。一个请求消息是一个带有 Response Topic 的应用消息
2. 另一个 MQTT 客户端（响应者）已订阅主题过滤器，该主题过滤器与发布请求消息时所使用的主题名称相匹配。因此，它会接收到 Request 消息。有可能会有多个响应者订阅到该 Topic Name ，一个订阅到该 Topic Name 的订阅者都没有。
3. 响应者会基于请求消息采取适当的操作，然后将响应消息发布到请求消息上携带的响应主题属性中的主题名称。
4. 典型的使用方法是这样的：请求者已订阅响应主题，从而接收响应消息。但是，某些其它的客户端可能会订阅响应主题，在这种情况下，响应消息也将由该客户端接收和处理。与请求消息一样，发送响应消息的主题可以由多个客户端订阅，也可以没有任何客户端订阅。

如果请求消息中包含了一个 Correlation Data 属性，响应者会把这个属性拷贝到响应消息中，它会被响应消息的接收者用来将其与带有最初请求的响应消息关联起来。而这个响应消息并不包含 Response Topic 属性。

MQTT 服务器会转发请求消息中的 Response Topic 和 Correlation Data 属性以及响应消息中的 Correlation Data。服务器会将 Request Message 和 Response Message 当作其它 Application Message 一样对待。

请求者在发布 Request Message 之前就会正常地订阅 Response Topic。当 Response Message 被发出的时候，如果没有订阅者订阅到响应主题，响应消息就不会传递到客户端。

请求消息和响应消息可以是任意的 QoS 等级，响应者可以使用一个带有非 0 Session Expiry Interval 。通常会以 QoS 0 的等级去发送请求消息并且只有仅当预期响应者连接时发送。但是，这只是通常情况下的做法，不代表你只能这么做。

响应者可以使用共享订阅来允许响应客户端池。但请注意，使用共享订阅时，不保证多个客户端之间的消息传递顺序。

请求者负责确保它有足够的权限来发布 request topic 并且订阅到它设定了 Response Topic 属性的 Topic Name 。响应者负责确保它有足够的权限去去订阅请求 topic 并且发布到响应主题。虽然主题授权不在本标准描述的规范范围内，但建议服务器去按照这样的授权方式去实现。

### Determining a Response Topic value (non-normative)
请求者可以通过他们选择的任何方式（包括通过本地配置）来确定要用作其响应主题的主题名称。为了避免不同请求者间的冲突，请求者客户端使用的响应主题对于该客户端最好是唯一的。
由于请求者和响应者通常需要被授权使用这些主题，因此使用随机主题名称是非常具有挑战性的。

为了帮助解决这个问题，mqtt v5.0 标准规范定义了 CONMACK 包中的 Response Information 属性。服务器可以使用该属性去指导客户选择要使用的响应主题。对于客户端和服务器，此机制是可选的。在连接时，客户端请求服务器去通过在 CONNECT 包中设置 Request Response  Information 属性来发送响应信息。这会使服务器在要发送的 CONNACK 包中插入一个 Response Information 属性(一个 UTF-8 编码字符串)

这份标准未定义响应信息的内容，但是它可以用来传递一个主题树的全局唯一的部分，该部分至少在其会话的生命周期内为该客户端保留。使用此机制允许此配置在服务器中而不是在每个客户端中完成一次。

## Server redirection
服务器可以通过发送带有 0x9c (使用另一台服务器)原因码或 0x9D (服务器被移除)原因码的 CONNACK 或 DISCONNECT 包来请求客户端去更换另一台服务器。当发送这些原因码的时候，服务器也可以通过包含一个 Server Reference 属性去指明服务器或客户端应该去使用的服务器的位置。

0x9C 原因码（使用另一台服务器）表示服务器需要暂时切换到另一台服务器上。另一台服务器要么已被客户端所知，要么已经被规定使用了Server Reference。

0x9D 原因码（服务器被移除）表示服务器应该永远地切换到另一台服务器上。另一台服务器要么已被客户端所知，要么已经被规定使用了Server Reference。

Server Reference 是一个 UTF-8 编码的字符串。这个字符串的值是一个由空格分隔开来的引用的列表。引用的格式没有在这里指定。

通常建议每一个引用包含一个名字后面可选地跟上一个冒号和一个端口号。如果名字包含了冒号，那么这个名字就可以用一个方括号("[“和”]")包起来。被用方括号包起来的名字里面不能包含右方括号"["，它通常用来表示一个使用冒号分隔符的 IPv6 地址。

Server Reference 中的名字通常会表示主机名，DNS 名，SRV 名或 IP地址跟在冒号后面的值通常会是一个十进制的数字来表示端口号。如果端口名字来自名称解析（例如使用 SRV）或默认，则不需要这样做。

服务器也可以不发送 Server Reference，客户端也可以忽略 Server Reference，此功能用于负载均衡，服务器重定位和客户端配置到服务器。

## Enhanced authentication
MQTT CONNECT 包通过使用 User Name 和 Password 字段来支持网络连接的基本认证。虽然这些字段以简单的密码身份验证命名，但它们可用于执行其他形式的身份验证，例如将令牌作为密码传递。

增强认证通过包含询问/响应式的认证来扩展基础认证的方式。它在 CONNECT 之后和 CONNACK 数据包之前在客户端和服务器之间交换 AUTH 数据包。

客户端需要在 CONNECT 包中包含一个认证方法来开始增强认证。它指定了要使用的认证方法。如果服务器不支持客户端提供的认证方法，它可以发送一个带有 0x8C 原因码（错误的验证方法）或 0x87 (未验证)并且必须关闭网络连接。

身份验证方法是客户端和服务器之间关于身份验证数据中发送的数据含义以及 CONNECT 中任何其他字段的协议，以及客户端和服务器完成身份验证所需的交换和处理。

身份验证方法通常是 SASL 机制，使用这样的注册名有助于交换。但是，身份验证方法不限于使用已注册的 SASL 机制.

如果客户端选用的验证方法要求客户端先发送数据，那么客户端应该在 CONNECT 包中包含一个 Authentication Data 属性。该属性是用来像 Authentication Method 指定的那样提供数据。Authentication Data 的内容是由验证方法来定义的。

如果服务器需要额外的信息来完成验证，它就发送一个 AUTH 包给客户端。这个包必须包含一个 0x18 原因码（继续验证）。如果验证方法需要服务器去发送 authentication data 给客户端，它就会在 Authentication Data 中被发送。

客户端通过发送另一个 AUTH 数据包来响应来自服务器的 AUTH 数据包。这个包必须包含一个 0x18 原因码（继续验证）。如果验证方法需要客户端去发送 authentication data 给服务器，它就会在 Authentication Data 中被发送。

客户端和服务器根据需要交换 AUTH 数据包，直到服务器通过发送原因代码为 0 的 CONNACK 包接受身份验证。如果接受身份认证需要将数据发送到客户端，则会在身份认证数据中发送。

客户端可以在运行的任何时刻关闭网络连接。在断开连接之前它可以发送一个 DISCONNECT 包。服务器可以在运行的任何时刻拒绝认证。它可以发送带有 0x80 原因码的 CONNACK 包并且它必须关闭网络连接。

如果初始 CONNECT 数据包包含了 Authentication Method 属性，则所有 AUTH 包和任何成功的 CONNACK 包都必须包含 Authentication Method 属性，其值要与 CONNECT 包中的 Authentication Method 属性一样。

增强认证的实现对于客户端和服务器来说都是可选的。如果客户端没有在 CONNECT 中包含 Authentication Method ，服务器就不能发送 AUTH 包，并且它不能在 CONNACK 包中发送 Authentication Method 。如果客户端在 CONNECT 中不包含 Authentication Method,那么客户端就不能发送 AUTH 包给服务器。

如果客户端没有在 CONNECT 包中包含 Authentication Method ，服务器就应该授权使用 CONNECT 包中的一些或全部信息，TLS 会话以及网络连接。

### Re-authentication（重验证）
如果客户端在 CONNECT 包中支持 Authentication Method, 那么它就可以在接收到 CONNACK 包后的任何时刻去随时启动重新验证。它通过发送一个带有 0x19 原因码的 AUTH 包来完成此操作。客户端必须将 Authentication Method 的值设为和最初用于验证网络连接的 Authentication Method 一样的值。如果 authentication method 首先需要客户端数据，则此 AUTH 包包含的第一个验证数据会作为 Authentication Data。

服务器通过发送一个带有 0x00 原因码(Success)的 AUTH 包给客户端来响应 re-authentication 请求，去告知 re-authentication 已经完成了，或者也可以发送带有 0x18 原因码 (继续验证) 去告知需要更多的验证数据。客户端可以通过发送带有 0x18 原因码（继续验证）的 AUTH 包去响应额外的验证数据。在重新验证完成或重新验证失败前，这个流程都会不断地循环继续下去。

如果重新验证失败了，客户端和服务器应该发送带有适当原因码的 DISCONNECT 包并且必须关闭网络连接。

在重新验证序列期间，客户端和服务器之间的其他数据包流可以继续使用之前的验证。

服务器可能会通过拒绝重新身份验证来限制客户端在重新身份验证中尝试的更改范围。例如，如果服务器不允许更改用户名，则可能会导致任何尝试去更改用户名的重新验证的行为失败。

## Handling errors
### Malformed Packet and Protocol Errors
Malformed Packet 和　Protocol Errors 的定义都包含在 1.2 节中，在整个协议说明中你能看到在很多地方都会提到这些错误情况。

客户端或服务器检查它收到的 MQTT 控制数据包的严格性会在以下几个方面之间妥协：
* 客户端或服务器实现的大小
* 实现支持的功能
* 接收方信任发送方发送 MQTT 控制包的程度
* 接收方信任网络正确发送 MQTT 控制包的程序
* 继续处理不正确包的后果

如果发送方遵循这份协议说明去发包，一般情况下就不会发出 Malformed Packets 或者有导致协议错误的情况出现。但是，如果客户端在它接收到 CONNACK 包之前发送 MQTT 控制包，则可能会导致协议错误，因为它对服务器功能做出了错误的假设。

用来表示 Malformed Packet 或 Protocol Errors 的原因码有以下这些：
*    0x81    （格式错误的包）Malformed Packet 
*    0x82    （协议错误）Protocol Error
*    0x93    （超出可以接收的最大值）Receive Maximum exceeded
*    0x95    （包太大）Packet too large
*    0x9A    （不支持 Retain）Retain not supported
*    0x9B    （不支持 QoS）QoS not supported
*    0x9E    （不支持共享订阅）Shared Subscription not supported
*    0xA1    （不支持订阅标识符）Subscription Identifier not supported
*    0xA2    （不支持通配符订阅）Wildcard Subscription not supported

当客户端检测到格式错误的包或协议错误的时候并且检测到本协议给出的原因码的时候，它会关闭网络连接。在 CONNECT 包有错误的情况下，它可在网络连接关闭前发送一个包含原因码的 CONNACK 包。在其它包有错误的情况下，它应该在网络连接关闭之前发送一个包含原因码的 DISCONNECT 包。一般情况下建议用 Malformed Packet 和 Protocol Error 除非有其它可以用来表示特定原因的原因码。（这些原因码在前一章介绍 CONNECT 包和 DISCONNECT 包的时候介绍过）

如果服务器和客户端都忽略检查 MQTT 控制包的某些功能，那么它可能无法成功地检测到错误，因此可能会导致数据损坏。

### 其它错误
发送者很难预测到 Malformed Packet 和协议错误以外的错误，因为接收方可能与还未开始通信的发送方之间存在某些限制。接收客户端或服务器可能会遇到某些暂时性错误，比如内存不足，导致无法成功处理单个 MQTT 控制包。

当接收到的确认包比如 PUBACK, PUBREC, PUBREL, PUBCOMP, SUBACK, UNSUBACK 中的 Reason Code 大于等于 0x80 时，则表示由数据包标识符标识的接收数据包出错。对同一会话中流动的其它数据包或其它会话没有影响。

CONNACK 和 DISCONNECT 包允许大于等于 0x80 的 Reason Code 来表示网络连接即将关闭。如果指定了大于等于 0x80 的 Reason Code，那么不管 CONNACK 或 DISCONNECT包有没有被发出，都需要关闭网络连接。发出的这些 Reason Code 不会对其它会话有影响。

如果控制包包含了多个错误，则数据包的接收者可以按照任何顺序来验证数据包。并对发现的任何错误采取适当的措施。

# Security
## 介绍
MQTT v5.0 强烈推荐服务器实现提供的 TLS 功能应该使用TCP 8883 的端口（IANA 服务名为: secure-mqtt）

安全领域的变化非常快，所以在设计安全解决方案的时候请按照最新的建议来做。

其它都和 v3.1.1 一样。

## MQTT 解决方案: 安全和认证
和 v3.1.1 一样。

## 轻量级密码和受限设备
高级加密标准 [AES] 是使用最广泛的加密算法，许多处理器都对该算法提供硬件级的支持，但是很嵌入式设备的处理器就没有提供硬件级的算法支持了。加密算法 ChaCha20 在软件层面做加密和解密处理时要比 AES 快得多，但是没有 AES 算法用的那么广泛。

其它和 v3.1.1 一样。

## 实现注意
和 v3.1.1 一样。

### 服务器验证客户端
MQTT v5.0 增强了验证机制，在 4.12 节中已经提到过了，使用该机制需要客户端和服务器都支持该机制。

### 服务器授权客户端
如果客户端已经被成功验证，服务器实现就应该在接收客户端的连接之前检查是否客户端被授权。

授权基于客户端提供的信息来做的，比如用户名，客户端所在的域名或 IP 地址，或者验证机制的结果。

特别需要注意的是，服务器实现应该检查客户端是否有权使用客户端标识符，因为客户端标识符可以给权限来访问 MQTT 会话状态。此授权检查是用于防止这种情况：客户端意外或恶意地提供已被其它客户端使用的客户端标识符。

服务器实现应提供在 CONNECT 之后发生的访问控制，去限制客户端发布消息到特定主题或订阅到特定主题过滤器。实现应考虑限制访问有很大范围的主题过滤器，例如带通配符“#”号的 Topic Filter。

### 客户端验证服务器

MQTT 协议不是信任对称的。当使用基础认证的时候，没有任何机制去让客户端去验证服务器。某些形式的扩展认证可以允许相互认证。

实现可能允许通过从服务器发送到客户端的应用程序消息中的凭据来发送验证。MQTT v5.0 协议中提供了增强验证机制来给客户端用来验证服务器。使用该机制需要客户端和服务器都支持该机制。

### 应用消息和 MQTT 控制包的完整性
和 v3.1.1 一样

### 应用消息和 MQTT 控制包的隐私性
和 v3.1.1 一样

### 消息传输的不可否认性
和 v3.1.1 一样

### 检测客户端和服务器上的调用
和 v3.1.1 一样

### 检测异常行为
和 v3.1.1 一样

### 其它安全注意事项
在长连接那里与 v3.1.1 一同：

* 客户端和服务端使用TLS [RFC5246] 时应该允许重新协商会话以确认新的加密参数（替换会话密钥，更换密码组合，更换认证凭证）。
* 服务端可以关闭和客户端的网络连接，并要求他们使用新的凭证重新验证身份。
* 服务器可能要求其客户端使用该机制　定期重新进行验证。

其它和 v3.1.1 一样。

### 使用 SOCKS 代理　
和 v3.1.1 一样

### 安全配置文件
和 v3.1.1 一样

# 使用 WebSocket 作为网络传输协议
和 v3.1.1 一样

# 一致性
## 一致性条例
### MQTT 服务器一致性条例


一个MQTT服务端只有满足下面所有的要求才算是符合本规范：
1. 服务端发送的所有控制报文的格式必须符合第二章和第三章描述的格式
2. 遵守第 4.7 节描述的主题匹配规则以及第 4.8 节描述的订阅规则
3. 满足下列章节中所有必须级别的要求，明确仅适用于对客户端的除外：
   * 第一章 – 介绍
   * 第二章 – MQTT控制报文格式
   * 第三章 – MQTT控制报文
   * 第四章 – 操作行为
   * 第六章 –（如果MQTT的网络层是WebSocket）
4. 它不需要使用规范之外定义的任何扩展，以便与其他符合要求的实现进行互操作。

### MQTT 客户端一致性条例

一个MQTT客户端只有满足下面所有的要求才算是符合本规范：
1. 客户端发送的所有控制报文的格式必须符合第二章和第三章描述的格式
2. 满足下列章节中所有必须级别的要求，明确仅适用于对服务端的除外：
   * 第一章 – 介绍
   * 第二章 – MQTT控制报文格式
   * 第三章 – MQTT控制报文
   * 第四章 – 操作行为
   * 第六章 – （如果MQTT的网络层是WebSocket）
3. 它不需要使用规范之外定义的任何扩展，以便与其他符合要求的实现进行互操作。
